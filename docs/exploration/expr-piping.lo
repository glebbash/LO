fn main() {
    do stderr_write(it) with (
        // context:
        token.loc.pos.line.to_tmp_str!(),
        ":", \\ token.loc.pos.col.to_tmp_str!(),
        "-",
        token.loc.end_pos.line.to_tmp_str!(),
        ":", \\ token.loc.end_pos.col.to_tmp_str!(),

        " ", \\ "(", \\ token.loc.pos.offset.to_tmp_str!(),
        "-", \\ token.loc.end_pos.offset.to_tmp_str!(), \\ ")",

        " ", \\ token.type_.to_str(),

        " ", \\ ">> ",

        // option 1:
        String::from_str_in(a, token.loc.read_span(lexer.source)) \
            .replace("\n", "\\n").as_str(),
        // option 2:
        token.loc.read_span(lexer.source) \
            |> String::from_str_in(a, it).replace("\n", "\\n") \
            .as_str(),
        // option 3:
        token.loc.read_span(lexer.source) \
            |> String::from_str_in(a, it)
            |> it.replace("\n", "\\n") \
            |> it.as_str(),
        // option 4:
        token.loc.read_span(lexer.source) \
            |> String::from_str_in(a, it)
            |> String::replace(it, "\n", "\\n") \
            |> String::as_str(it),
        " <<",

        "\n",
    )

    // Thoughts:
    //
    // option 1: though having least features forces you to
    //     read inside out and then left to right
    //
    // option 2: while it flows proper like in a book I think it looks
    //     a little ugly where lines start with either a pipe or a method call
    //
    // option 3: is a nice unexpected middle ground
    //     still uses pipes but does not forbid method calls,
    //     it actually looks really nice, never expected this mix to be nice
    //
    // option 4: goes all in on piping and not using methods
    //     which is fine but it does add more typing
    //     and completely changes the style of the language
}


