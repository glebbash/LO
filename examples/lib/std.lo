type str = struct {
    ptr: &[]u8,
    len: u32,
}
@str_literal_type<str>()

// constants

inline let u32::MAX = 4_294_967_295

let STATIC_DATA_SIZE = @data_size()

// abort

type AbortCode = u32

inline let AbortCode::SHOULD_NOT_HAPPEN = 0
inline let AbortCode::OOM = 1
inline let AbortCode::STACK_OVERFLOW = 2
inline let AbortCode::STACK_UNDERFLOW = 3
inline let AbortCode::VEC_OUT_OF_BOUNDS = 4
inline let AbortCode::STACK_VECTOR_GROW = 5

fn abort(abort_code: AbortCode): never {
    // error indicator
    *(0 as &u32) = 69420
    *(4 as &u32) = abort_code
    @unreachable()
}

// memory instructions

inline let mem::PAGE_SIZE = 65_536

fn mem::align(size: u32): u32 {
    return mem::align_to(size, sizeof &void)
}

fn mem::align_to(size: u32, size_multiple: u32): u32 {
    let remaining_to_align = size % size_multiple
    if remaining_to_align == 0 {
        return size
    }
    let padding = size_multiple - remaining_to_align
    return size + padding
}

inline fn mem::copy!(src: &void, dest: &void, size: u32) {
    @memory_copy(dest as u32, src as u32, size)
}

fn mem::swap(ref1: &void, ref2: &void, size: u32) {
    while size != 0 {
        size -= 1
        let tmp = *((ref1 as u32 + size) as &u8)
        *((ref1 as u32 + size) as &u8) = *((ref2 as u32 + size) as &u8)
        *((ref2 as u32 + size) as &u8) = tmp
    }
}

// allocator interface

type Alloc = &void
inline let Alloc::STACK = 0 as Alloc
inline let Alloc::HEAP = 1 as Alloc

inline fn new!(a: Alloc, value: infer(T)): &T {
    let ptr = alloc(a, sizeof T) as &T
    *ptr = value
    ptr
}

inline fn alloc!<T>(a: Alloc): &T {
    alloc(alloc, sizeof T) as &T
}

inline fn alloc_many!<T>(a: Alloc, count: u32): &[]T {
    alloc(alloc, count * sizeof T) as &[]T
}

fn alloc(a: Alloc, size: u32): &void {
    if a == Alloc::STACK {
        return stack::alloc(size)
    }

    if a == Alloc::HEAP {
        return heap::alloc(size)
    }

    return (a as &Arena).alloc(size)
}

inline fn free!<T>(a: Alloc, ptr: &T) {
    free(a, ptr, sizeof T)
}

inline fn free_many!<T>(a: Alloc, ptr: &[]T, count: u32) {
    free(alloc, ptr, count * sizeof T)
}

fn free(a: Alloc, ptr: &void, size: u32) {
    if a == Alloc::STACK {
        return stack::free(size)
    }

    if a == Alloc::HEAP {
        return heap::free(ptr)
    }

    // arena free is a noop
}

// stack allocator

// 1MB, ~20 pages (65_536b)
let stack::SIZE = 1_048_576

// not initialized yet marker
let stack::MIN = u32::MAX

let stack::NOW = 0

inline fn stack::align_for_wasmtime!(alignment: u32) {
    stack::check_init!()
    let current = stack::NOW
    let to_align = mem::align_to(current, alignment) - current
    let _ = tmp_alloc_many!<u8>(to_align)
}

inline fn stack::alloc!<T>(): &T {
    stack::alloc(sizeof T) as &T
}

fn stack::alloc(size: u32): &void {
    size = mem::align(size)
    stack::check_init!()
    stack::NOW += size
    if stack::NOW > stack::MIN + stack::SIZE {
        abort(AbortCode::STACK_OVERFLOW)
    }
    return (stack::NOW - size) as &void
}

inline fn stack::check_init!() {
    if stack::MIN == u32::MAX {
        stack::MIN = mem::align(STATIC_DATA_SIZE)
        stack::NOW = stack::MIN
    }
}

inline fn stack::free!<T>() {
    stack::free(sizeof T)
}

fn stack::free(size: u32) {
    size = mem::align(size)
    stack::NOW -= size
    if stack::NOW < stack::MIN {
        abort(AbortCode::STACK_UNDERFLOW)
    }
}

// tmp alloc utils (stack + defer free)

inline fn ref!(value: infer(T)): &T {
    let value_ref = tmp_alloc!<T>()
    *value_ref = value
    value_ref
}

inline fn tmp_alloc!<T>(): &T {
    stack::alloc(sizeof T) as &T
    defer stack::free(sizeof T)
}

inline fn tmp_alloc_many!<T>(count: u32): &[]T {
    stack::alloc(count * sizeof T) as &[]T
    defer stack::free(count * sizeof T)
}

// heap allocator

type heap::Block = struct {
    size: u32,
    used: bool,
}

inline fn heap::Block::data!(&self): &void {
    (self as u32 + sizeof heap::Block) as &void
}

inline fn heap::Block::next!(&self): &heap::Block {
    (self.data!() as u32 + self.size) as &heap::Block
}

let heap::FIRST_BLOCK = null as &heap::Block

let heap::CURRENT_BLOCK = null as &heap::Block

inline fn heap::new!(value: infer(T)): &T {
    let ptr = heap::alloc!<T>()
    *ptr = value
    ptr
}

inline fn heap::alloc!<T>(): &T {
    heap::alloc(sizeof T) as &T
}

inline fn heap::alloc_many!<T>(count: u32): &[]T {
    heap::alloc(count * sizeof T) as &[]T
}

// http://dmitrysoshnikov.com/compilers/writing-a-memory-allocator/#mutator-allocator-collector
fn heap::alloc(size: u32): &void {
    size = mem::align(size)

    let free_block = heap::find_free_block(size)
    if free_block != null {
        free_block.used = true
        return free_block.data!()
    }

    if heap::CURRENT_BLOCK == null {
        stack::check_init!()
        heap::CURRENT_BLOCK = (stack::MIN + stack::SIZE) as &heap::Block
        heap::FIRST_BLOCK = heap::CURRENT_BLOCK
    } else {
        heap::CURRENT_BLOCK = heap::CURRENT_BLOCK.next!()
    }

    let new_memory_needed = (
        heap::CURRENT_BLOCK as u32 + sizeof heap::Block + size,
    ) as i32 - @memory_size() * mem::PAGE_SIZE as i32
    if new_memory_needed > +0 {
        let pages_needed = (new_memory_needed as u32 + mem::PAGE_SIZE) \
            / mem::PAGE_SIZE
        if @memory_grow(pages_needed) == -1 {
            abort(AbortCode::OOM)
        }
    }

    heap::CURRENT_BLOCK.size = size
    heap::CURRENT_BLOCK.used = true

    return heap::CURRENT_BLOCK.data!()
}

fn heap::free(ptr: &void) {
    let block = heap::get_block(ptr)
    block.used = false
}

fn heap::get_block(ptr: &void): &heap::Block {
    return (ptr as u32 - sizeof heap::Block) as &heap::Block
}

// first fit
fn heap::find_free_block(size: u32): &heap::Block {
    let block = heap::FIRST_BLOCK
    if block == null {
        return null
    }
    loop {
        if !block.used && block.size >= size {
            return block
        }
        if block as u32 == heap::CURRENT_BLOCK as u32 {
            break
        }
        block = block.next!()
    }
    return null
}

// arena allocator

type Arena = struct {
    head: &Arena::Block,
    tail: &Arena::Block,
    block_size: u32,
    alloc: Alloc,
}

type Arena::Block = struct {
    next: &Arena::Block,
    size: u32,
    used: u32,
    data: &void,
}

fn Arena::Block::new(a: Alloc, size: u32): &Arena::Block {
    let data = alloc(a, size)
    return new!(a, Arena::Block {
        next: null,
        size: size,
        used: 0,
        data: data,
    })
}

fn Arena::new(block_size: u32): &Arena {
    return Arena::new_in(Alloc::HEAP, block_size)
}

fn Arena::new_in(a: Alloc, block_size: u32): &Arena {
    let block = Arena::Block::new(a, block_size)
    return new!(a, Arena {
        head: block,
        tail: block,
        block_size: block_size,
        alloc: a,
    })
}

inline fn Arena::new!(&self, value: infer(T)): &T {
    let ptr = self.alloc(sizeof T) as &T
    *ptr = value
    ptr
}

inline fn Arena::alloc!<T>(&self): &T {
    self.alloc(sizeof T) as &T
}

inline fn Arena::alloc_many!<T>(&self, count: u32): &[]T {
    self.alloc(count * sizeof T) as &[]T
}

fn Arena::alloc(&self, size: u32): &void {
    size = mem::align(size)
    let block = self.tail

    if block.used + size > block.size {
        let new_block_size = self.block_size
        if size > self.block_size {
            new_block_size = size
        }
        let new_block = Arena::Block::new(self.alloc, new_block_size)
        self.tail.next = new_block
        self.tail = new_block
        block = new_block
    }

    let ptr = (block.data as u32 + block.used) as &void
    block.used += size
    return ptr
}

fn Arena::reset(&self) {
    let block = self.head
    loop {
        block.used = 0
        if block.next == null {
            break
        }
        block = block.next
    }
    self.tail = self.head
}

fn Arena::free(&self) {
    let block = self.head
    loop {
        free(self.alloc, block.data, block.size)

        let next_block = block.next
        free!<Arena::Block>(self.alloc, block)
        if next_block == null {
            break
        }
        block = next_block
    }
    free!<Arena>(self.alloc, self)
}

// vec
type Vec = struct {
    ptr: &void,
    len: u32,
    capacity: u32,
    item_size: u32,
    alloc: Alloc,
}

inline fn Vec::new!<T>(): &Vec(T) {
    Vec::new(sizeof T)
}

fn Vec::new(item_size: u32): &Vec {
    return Vec::with_capacity(10, item_size)
}

fn Vec::new_in(a: Alloc, item_size: u32): &Vec {
    return Vec::with_capacity_in(a, 10, item_size)
}

inline fn Vec::with_capacity!<T>(capacity: u32): &Vec(T) {
    Vec::with_capacity(capacity, sizeof T)
}

fn Vec::with_capacity(capacity: u32, item_size: u32): &Vec {
    return Vec::with_capacity_in(Alloc::HEAP, capacity, item_size)
}

inline fn Vec::with_capacity_in!<T>(a: Alloc, capacity: u32): &Vec(T) {
    Vec::with_capacity_in(a, capacity, sizeof T)
}

fn Vec::with_capacity_in(a: Alloc, capacity: u32, item_size: u32): &Vec {
    return new!(a, Vec {
        ptr: alloc(a, capacity * item_size),
        len: 0,
        capacity: capacity,
        item_size: item_size,
        alloc: a,
    })
}

inline fn Vec::free_deep!<T>(&self) {
    for i in 0..self.len {
        self.get!(i).free()
    }
    self.free()
}

fn Vec::free(&self) {
    free!<Vec>(self.alloc, self)
    free(self.alloc, self.ptr, self.capacity)
}

inline fn Vec::at!(&self, index: u32): &itemof(typeof(self)) {
    self.at(index) as &itemof(typeof(self))
}

inline fn Vec::get!(&self, index: u32): itemof(typeof(self)) {
    *self.at!(index)
}

inline fn Vec::set!(&self, index: u32, item: itemof(typeof(self))) {
    *self.at!(index) = item
}

fn Vec::at(&self, index: u32): &void {
    self._panic_if_out_of_bounds!(index)
    return (self.ptr as u32 + index * self.item_size) as &void
}

fn Vec::at_unchecked(&self, index: u32): &void {
    return (self.ptr as u32 + index * self.item_size) as &void
}

fn Vec::swap(&self, index1: u32, index2: u32) {
    self._panic_if_out_of_bounds!(index1)
    self._panic_if_out_of_bounds!(index2)
    let item_size = self.item_size
    let item_addr1 = (self.ptr as u32 + index1 * item_size) as &void
    let item_addr2 = (self.ptr as u32 + index2 * item_size) as &void
    mem::swap(item_addr1, item_addr2, item_size)
}

inline fn Vec::push!(&self, item: itemof(typeof(self))) {
    *(self.push() as &itemof(typeof(self))) = item
}

fn Vec::push(&self): &void {
    self._grow_to_len(self.len + 1)
    return self.at_unchecked(self.len - 1)
}

fn Vec::push_all(&self, items: &void, items_len: u32) {
    let prev_len = self.len
    self._grow_to_len(prev_len + items_len)
    let items_dest = (self.ptr as u32 + prev_len * self.item_size) as &void
    mem::copy!(items, items_dest, items_len * self.item_size)
}

fn Vec::pop(&self) {
    self.len -= 1
}

fn Vec::reverse(&self) {
    self.reverse_range(0, self.len - 1)
}

fn Vec::reverse_range(&self, start: u32, end: u32) {
    while start < end {
        self.swap(start, end)
        start += 1
        end -= 1
    }
}

fn Vec::_grow_to_len(&self, new_len: u32) {
    if new_len <= self.capacity {
        self.len = new_len
        return
    }

    if self.alloc == Alloc::STACK {
        abort(AbortCode::STACK_VECTOR_GROW)
    }

    let old = *self

    let new_capacity = u32::max!(old.capacity * 2, new_len)
    let new_ptr = alloc(old.alloc, new_capacity * old.item_size)

    if old.capacity != 0 {
        mem::copy!(old.ptr, new_ptr, old.len * old.item_size)
        free(old.alloc, old.ptr, old.capacity * old.item_size)
    }

    self.ptr = new_ptr
    self.capacity = new_capacity
    self.len = new_len
}

inline fn Vec::_panic_if_out_of_bounds!(&self, index: u32) {
    if index < 0 || index >= self.len {
        abort(AbortCode::VEC_OUT_OF_BOUNDS)
    }
}

// string
type String = struct {
    chars: &Vec(u8),
}

fn String::new(capacity: u32): String {
    return String {
        chars: Vec::with_capacity!<u8>(capacity),
    }
}

fn String::new_in(a: Alloc, capacity: u32): String {
    return String {
        chars: Vec::with_capacity_in!<u8>(a, capacity),
    }
}

fn String::from_chars(chars: &Vec(u8)): String {
    return String { chars: chars }
}

fn String::from_str(value: str): String {
    return String::from_str_in(Alloc::HEAP, value)
}

fn String::from_str_in(a: Alloc, value: str): String {
    let string = String::new_in(a, value.len)
    string.chars.push_all(value.ptr, value.len)
    return string
}

fn String::free(self) {
    self.chars.free()
}

fn String::clone(self): String {
    return String::from_str(self.as_str())
}

fn String::len(self): u32 {
    return self.chars.len
}

fn String::push_str(self, value: str) {
    self.chars.push_all(value.ptr, value.len)
}

fn String::push(self, c: u8) {
    self.chars.push!(c)
}

fn String::char_at(self, index: u32): u8 {
    return self.chars.get!(index)
}

// in-place modification, returns self
fn String::replace(self, search: str, replacement: str): String {
    if search.len == 0 {
        return self
    }

    if self.chars.alloc == Alloc::STACK {
        abort(AbortCode::STACK_VECTOR_GROW)
    }

    let original = self.as_str()
    let replaced = String::new_in(self.chars.alloc, self.len())

    let pos = 0
    loop {
        let index = original.find(search, pos) catch _ {
            replaced.push_str(original.slice(pos, original.len))
            break
        }

        replaced.push_str(original.slice(pos, index))
        replaced.push_str(replacement)

        pos = index + search.len
    }

    self.chars.free()
    self.chars = replaced as &Vec(u8)

    return self
}

fn String::join(items: &Vec(str), separator: u8): String {
    let output = String::new(32)
    for i in 0..items.len {
        output.push_str(items.get!(i))
        if i + 1 < items.len {
            output.push(separator)
        }
    }
    return output
}

fn String::as_str(self): str {
    return str {
        ptr: self.chars.ptr as &[]u8,
        len: self.chars.len,
    }
}

// str utils

fn str::char_at(self, index: u32): u8 {
    return *array_at!<u8>(self.ptr, index)
}

fn str::clone(self): str {
    let new_ptr = heap::alloc_many!<u8>(self.len)
    mem::copy!(self.ptr, new_ptr, self.len)

    return str { ptr: new_ptr, len: self.len }
}

fn str::equals(self, other): bool {
    if self.len != other.len {
        return false
    }

    for i in 0..self.len {
        if self.char_at(i) != other.char_at(i) {
            return false
        }
    }

    return true
}

fn str::contains(self, search: str): bool {
    let _ = self.find(search, 0) catch _ {
        return false
    }

    return true
}

fn str::find(self, search: str, start: u32): Result(u32, &void) {
    if search.len == 0 {
        return Ok(start)
    }

    if search.len > self.len {
        return Err(1 as &void)
    }

    for i in start..(self.len - search.len + 1) {
        if self.slice(i, i + search.len).equals(search) {
            return Ok(i)
        }
    }

    return Err(1 as &void)
}

fn str::starts_with(self, other): bool {
    return self.slice(0, other.len).equals(other)
}

fn str::skip_chars(self, char_count: u32): str {
    return self.slice(char_count, self.len)
}

fn str::slice(self, start: u32, end: u32): str {
    if start >= self.len || end > self.len || start > end {
        return ""
    }

    return str {
        ptr: (self.ptr as u32 + start) as &[]u8,
        len: end - start,
    }
}

fn str::from_cstr(value: &[]u8): str {
    let len = 0
    while *array_at!<u8>(value, len) != '\0' {
        len += 1
    }
    return str { ptr: value, len: len }
}

fn str::split(self, separator: u8, output: &Vec(str)): &Vec(str) {
    let start = 0

    for i in 0..self.len {
        if self.char_at(i) == separator {
            output.push!(self.slice(start, i))
            start = i + 1
        }
    }

    output.push!(self.slice(start, self.len))

    return output
}

// conversions

inline fn u32::to_tmp_str!(self): str {
    let s = String::new_in(Alloc::STACK, 10)
    defer s.free()

    self.write_to(s)
    s.as_str()
}

inline fn u32::to_str_in!(self, a: Alloc): str {
    let s = String::new_in(a, 10)
    self.write_to(s)
    s.as_str()
}

fn u32::write_to(self, output: String) {
    let start_len = output.len()
    if self == 0 {
        output.push('0')
        return
    }
    loop {
        let rem = self % 10
        output.push('0' + rem as u8)
        self = self / 10
        if self == 0 {
            break
        }
    }
    output.chars.reverse_range(start_len, output.len() - 1)
}

inline fn u64::to_tmp_str!(self): str {
    let s = String::new_in(Alloc::STACK, 20)
    defer s.free()

    self.write_to(s)
    s.as_str()
}

fn u64::write_to(self, output: String) {
    let start_len = output.len()
    if self == 0u64 {
        output.push('0')
        return
    }
    loop {
        let rem = self % 10u64
        output.push('0' + rem as u32 as u8)
        self = self / 10u64
        if self == 0u64 {
            break
        }
    }
    output.chars.reverse_range(start_len, output.len() - 1)
}

// utils

inline fn array_at!<T>(array: &[]T, index: u32): &T {
    (array as u32 + index * sizeof T) as &T
}

inline fn u32::max!(a: u32, b: u32): u32 {
    let max = a
    if b > a {
        max = b
    }
    max
}
