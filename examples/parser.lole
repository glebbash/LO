(mod lib/std)

(struct Vec<Parser/SExpr> (actual Vec))

(struct Parser/Location
    (file_name StringSlice)
    (offset u32)
    (length u32)
    (line u32)
    (col u32)
)

(struct Parser/CompileError
    (&message (& String))
    (loc Parser/Location)
)

(fn Parser/CompileError/free [(self Parser/CompileError)] [] (
    (Vec/free {self . &message})
))

(struct Parser
    (file_name StringSlice)
    (chars StringSlice)
    (index u32)
    (line u32)
    (col u32)
)

(struct Parser/AtomKind (actual u32))
(global Parser/AtomKind/SYMBOL u32 0)
(global Parser/AtomKind/STRING u32 1)

(enum Parser/SExpr
    (Atom
        (&value (& String))
        (kind Parser/AtomKind)
        (loc Parser/Location)
    )
    (List
        (&value (& Vec<Parser/SExpr>))
        (loc Parser/Location)
    )
)

(struct Parser/ParseResult
    (ok bool)
    (data ptr) ; (& Parser/SExpr) | (& Parser/CompileError)
)

(struct Parser/ParseScriptResult
    (ok bool)
    (data ptr) ; (& Vec<Parser/SExpr>) | (& Parser/CompileError)
)

; public interface
(fn Parser/parse [(file_name StringSlice) (script StringSlice)] [Parser/ParseScriptResult] (
    {&parser : (& Parser) = (new Parser (Parser/new file_name script)
        :using Alloc/STACK)}
    (defer (Stack/free (sizeof Parser)))

    (return (Parser/parse_all &parser))
))

(fn Parser/new [(file_name StringSlice) (script StringSlice)] [Parser] (
    (return (struct.new Parser
        file_name
        script
        0 ; index
        1 ; line
        1 ; col
    ))
))

(fn Parser/parse_all [(&self (& Parser))] [Parser/ParseScriptResult] (
    (Parser/skip_space &self)

    {&items : (& Vec) = (Vec/new 10 (sizeof Parser/SExpr))}

    (loop (
        (if {Parser @ &self . index >= {Parser @ &self . chars . size}} (do
            (break)
        ))

        {res : Parser/CharAtResult = (Parser/current_char &self)}
        (if (not {res . ok}) (return res))

        (if (not (Parser/is_list_start {res . data})) (do
            (return (struct.new Parser/ParseScriptResult false
                (Parser/err_unexpected_char &self)))
        ))

        {expr_res : Parser/ParseResult = (Parser/parse_list &self)}
        (if (not {expr_res . ok}) (return expr_res))

        (Parser/skip_space &self)

        (Vec/push_all &items {expr_res . data} 1)
    ))

    (return (struct.new Parser/ParseScriptResult true
        &items))
))

(fn Parser/parse_expr [(&self (& Parser))] [Parser/ParseResult] (
    {res : Parser/CharAtResult = (Parser/current_char &self)}
    (if (not {res . ok}) (return res))

    (if (Parser/is_list_start {res . data}) (do
        (return (Parser/parse_list &self))
    ))

    (return (Parser/parse_atom &self))
))

(fn Parser/parse_atom [(&self (& Parser))] [Parser/ParseResult] (
    {res : Parser/CharAtResult = (Parser/current_char &self)}
    (if (not {res . ok}) (return res))

    (if {res . data == (char_code "\"")} (do
        (return (Parser/parse_string &self))
    ))

    (return (Parser/parse_symbol &self))
))

(fn Parser/parse_string [(&self (& Parser))] [Parser/ParseResult] (
    {loc : Parser/Location = (Parser/loc &self)}

    (Parser/next_char &self) ; skip start quote

    {&value : String = (Vec/new 6 1)}

    (loop (
        {res : Parser/CharAtResult}
        {res = (Parser/current_char &self)}
        (if (not {res . ok}) (return res))

        (if {res . data == (char_code "\"")} (do
            (break)
        ))

        (if {res . data != (char_code "\\")} (do
            (Vec/push_u8 &value {res . data})
            (Parser/next_char &self)
            (continue)
        ))
        (Parser/next_char &self) ; skip '\'

        {res = (Parser/current_char &self)}
        (if (not {res . ok}) (return res))

        (if {res . data == (char_code "n")} (do
            (Vec/push_u8 &value (char_code "\n"))
            (Parser/next_char &self)
            (continue)
        ))

        (if {res . data == (char_code "t")} (do
            (Vec/push_u8 &value (char_code "\t"))
            (Parser/next_char &self)
            (continue)
        ))

        (if {res . data == (char_code "\\")
                || {res . data == (char_code "\"")}} (do
            (Vec/push_u8 &value {res . data})
            (Parser/next_char &self)
            (continue)
        ))

        (return (struct.new Parser/ParseResult false
            (Parser/err_unexpected_char &self)))
    ))

    (Parser/next_char &self) ; skip end quote

    {loc . length = {Parser @ &self . index - {loc . offset}}}

    (return (struct.new Parser/ParseResult true
        (new Parser/SExpr (do
            (enum.kind Parser/SExpr/Atom)
            (new Parser/SExpr/Atom (do
                &value
                Parser/AtomKind/STRING
                loc
            ))
        ))
    ))
))

(fn Parser/parse_symbol [(&self (& Parser))] [Parser/ParseResult] (
    {loc : Parser/Location = (Parser/loc &self)}

    (loop (
        {res : Parser/CharAtResult = (Parser/current_char &self)}
        (if {(Parser/is_space {res . data})
                || (Parser/is_list_end {res . data})
                || {res . data == (char_code ";")}} (do
            (break)
        ))
        (Parser/next_char &self)
    ))

    {loc . length = {Parser @ &self . index - {loc . offset}}}

    {&value : (& String) = (String/from_slice
        {Parser @ &self . chars . data + {loc . offset}} {loc . length}) }

    (return (struct.new Parser/ParseResult true
        (new Parser/SExpr (do
            (enum.kind Parser/SExpr/Atom)
            (new Parser/SExpr/Atom (do
                &value
                Parser/AtomKind/SYMBOL
                loc
            ))
        ))
    ))
))

(fn Parser/parse_list [(&self (& Parser))] [Parser/ParseResult] (
    {loc : Parser/Location = (Parser/loc &self)}
    {res : Parser/CharAtResult}

    {res = (Parser/current_char &self)}
    (if (not {res . ok}) (return res))
    {list_start_char : u8 = {res . data}}
    (Parser/next_char &self) ; eat list start

    (Parser/skip_space &self)

    {&items : (& Vec<Parser/SExpr>) = (Vec/new 6 (sizeof Parser/SExpr))}

    (loop (
        {res = (Parser/current_char &self)}
        (if (not {res . ok}) (return res))

        (if (Parser/is_list_end {res . data}) (do
            (break)
        ))

        {expr_res : Parser/ParseResult = (Parser/parse_expr &self)}
        (if (not {expr_res . ok}) (return expr_res))
        (Vec/push_all &items {expr_res . data} 1)

        (Parser/skip_space &self)
    ))

    {res = (Parser/current_char &self)}
    (if (not {res . ok}) (return res))
    {list_end_char : u8 = {res . data}}
    (Parser/next_char &self) ; eat list end

    {loc . length = {Parser @ &self . index - {loc . offset}}}

    (if {list_start_char == (char_code "{") && {(Vec/len &items) >= 2}} (do
        (return (Parser/m_expr_to_s_expr_and_validate &items loc))
    ))

    (return (struct.new Parser/ParseResult true
        (new Parser/SExpr (do
            (enum.kind Parser/SExpr/List)
            (new Parser/SExpr/List (do &items loc))
        ))
    ))
))

(fn Parser/skip_space [(&self (& Parser))] [] (
    {res : Parser/CharAtResult}

    (loop (
        {res = (Parser/current_char &self)}
        (if (not {res . ok}) (return))
        (if (not (Parser/is_space {res . data})) (break))

        (Parser/next_char &self)
    ))

    (if {res . ok && {res . data != (char_code ";")}} (do
        (return)
    ))
    (Parser/next_char &self)

    (loop (
        {res = (Parser/current_char &self)}
        (if (not {res . ok}) (return))
        (if {res . data == (char_code "\n")} (break))
        (Parser/next_char &self)
    ))

    (if {res . data == (char_code ";")} (do
        (Parser/next_char &self)
    ))

    (Parser/skip_space &self)
))

; TODO(QOL?): add += operator
(fn Parser/next_char [(&self (& Parser))] [] (
    {Parser @ &self . index = {Parser @ &self . index + 1}}

    {res : Parser/CharAtResult = (Parser/current_char &self)}
    (if (not {res . ok}) (do
        (return)
    ))

    (if {res . data == (char_code "\n")} (do
        {Parser @ &self . col = 0}
        {Parser @ &self . line = {Parser @ &self . line + 1}}
        (return)
    ))

    {Parser @ &self . col = {Parser @ &self . col + 1}}
))

(struct Parser/CharAtResult
    (ok bool)
    (data u32) ; u8 | (& CompileError)
)

(fn Parser/current_char [(&self (& Parser))] [Parser/CharAtResult] (
    {chars : StringSlice = {Parser @ &self . chars}}

    (if {Parser @ &self . index >= {chars . size}} (do
        (return (struct.new Parser/CharAtResult
            false
            (Parser/err_unexpected_eof &self)))
    ))

    (return (struct.new Parser/CharAtResult
        true
        (StringSlice/char_at chars {Parser @ &self . index})))
))

(fn Parser/err_unexpected_char [(&self (& Parser))] [(& Parser/CompileError)] (
    (return (new Parser/CompileError (do
        (String/from_slice "ParseError: Unexpected character")
        (Parser/loc &self)
    )))
))

(fn Parser/err_unexpected_eof [(&self (& Parser))] [(& Parser/CompileError)] (
    (return (new Parser/CompileError (do
        (String/from_slice "ParseError: Unexpected EOF")
        (Parser/loc &self)
    )))
))

(fn Parser/loc [(&self (& Parser))] [Parser/Location] (
    (return (struct.new Parser/Location
        ; TODO(mem): clone file_name
        {Parser @ &self . file_name}
        {Parser @ &self . index}
        1 ; length
        {Parser @ &self . line}
        {Parser @ &self . col}
    ))
))

(fn Parser/m_expr_to_s_expr_and_validate [(&items (& Vec<Parser/SExpr>)) (loc Parser/Location)] [Parser/ParseResult] (
    (if {(Vec/len &items) % 2 != 1} (do
        (return (struct.new Parser/ParseResult false
            (new Parser/CompileError (do
                (String/from_slice "ParseError: Invalid m-expr: even length")
                loc
            ))
        ))
    ))

    (if {(Vec/len &items) < 2} (do
        (return (struct.new Parser/ParseResult true
            (new Parser/SExpr (do
                (enum.kind Parser/SExpr/List)
                (new Parser/SExpr/List (do &items loc))
            ))
        ))
    ))

    (return (struct.new Parser/ParseResult true
        (new Parser/SExpr (Parser/m_expr_to_s_expr &items loc))
    ))
))

; â“ {1 + 2 - 3 * 4}
; ðŸš« (+ 1 (- 2 (* 3 4)))
; âœ… (* (- (+ 1 2) 3) 4)
(fn Parser/m_expr_to_s_expr [(&items (& Vec<Parser/SExpr>)) (loc Parser/Location)] [Parser/SExpr] (
    (if {(Vec/len &items) == 1} (do
        ; TODO(mem): need to free &items and move expr out. How is Rust doing it?
        (return {Parser/SExpr @ (Vec/at &items 0)})
    ))

    {rhs : Parser/SExpr = {Parser/SExpr @ (Vec/pop_unchecked &items)}}
    {op : Parser/SExpr = {Parser/SExpr @ (Vec/pop_unchecked &items)}}
    ; TODO(mem): clone loc
    {lhs : Parser/SExpr = (Parser/m_expr_to_s_expr &items loc)}

    {&sexpr_items : (& Vec<Parser/SExpr>) = (Vec/new 3 (sizeof Parser/SExpr))}
    {Parser/SExpr @ (Vec/push_undef &sexpr_items) = op}
    {Parser/SExpr @ (Vec/push_undef &sexpr_items) = lhs}
    {Parser/SExpr @ (Vec/push_undef &sexpr_items) = rhs}

    (return (struct.new Parser/SExpr
        (enum.kind Parser/SExpr/List)
        (new Parser/SExpr/List (do &sexpr_items loc))
    ))
))

(fn Parser/is_list_start [(char u8)] [bool] (
    (return {
        {char == (char_code "(")} ||
        {char == (char_code "{")} ||
        {char == (char_code "[")}
    })
))

(fn Parser/is_list_end [(char u8)] [bool] (
    (return {
        {char == (char_code ")")} ||
        {char == (char_code "}")} ||
        {char == (char_code "]")}
    })
))

(fn Parser/is_valid_list_chars [(start u8) (end u8)] [bool] (
    (return {
        {start == (char_code "(") && {end == (char_code ")")}} ||
        {start == (char_code "{") && {end == (char_code "}")}} ||
        {start == (char_code "[") && {end == (char_code "]")}}
    })
))

(fn Parser/is_space [(char u8)] [bool] (
    (return {
        {char == (char_code " ")} ||
        {char == (char_code "\n")} ||
        {char == (char_code "\t")}
    })
))
