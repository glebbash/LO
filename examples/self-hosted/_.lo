// dependencies:
include "../lib/wasi.lo";
include "../lib/args.lo";
// tmp, for use in `std*_write` functions
include "../lib/print.lo";
// components:
include "./ast.lo";
include "./core.lo";
include "./wasm.lo";
include "./codegen.lo";
include "./lexer.lo";
include "./parser.lo";
include "./printer.lo";
include "./wasm_eval.lo";
include "./wasm_parser.lo";

export memory {
    min_pages: 1,
};

const USAGE = "Usage: lo <file> [<mode>]
  Where <mode> is either:
    --compile (default if not provided)
    --inspect
    --pretty-print
    --eval (experimental)
    --eval-wasm (experimental)";

export fn _start() {
    let res = try_start();
    stdout_disable_buffering();
    res catch err_message {
        defer err_message.free();
        stderr_write(err_message.as_str());
        stderr_write("\n");
        proc_exit(1);
    };
};

fn try_start(): Result<void, String> {
    let args = Args::load();
    defer args.free();
    if args.argc < 2 {
        return Err(String::from_str(USAGE));
    };
    let file_name = args.get(1);
    if file_name.equals("-i") {
        file_name = "<stdin>";
    };
    let compiler_mode = CompilerMode::Compile;
    if args.argc >= 3 {
        let compiler_mode_arg = args.get(2);
        if compiler_mode_arg.equals("--compile") {
            compiler_mode = CompilerMode::Compile;
        } else if compiler_mode_arg.equals("--inspect") {
            compiler_mode = CompilerMode::Inspect;
        } else if compiler_mode_arg.equals("--pretty-print") {
            compiler_mode = CompilerMode::PrettyPrint;
        } else if compiler_mode_arg.equals("--eval") {
            compiler_mode = CompilerMode::Eval;
        } else if compiler_mode_arg.equals("--eval-wasm") {
            compiler_mode = CompilerMode::EvalWasm;
        } else {
            let err_message = String::from_str("Unknown compiler mode: ");
            err_message.push_str(compiler_mode_arg);
            err_message.push_str("\n");
            err_message.push_str(USAGE);
            return Err(err_message);
        };
    };
    if compiler_mode == CompilerMode::PrettyPrint {
        let fm = FileManager::new();
        defer fm.free();
        let included_file = fm.include_file(file_name, LoLocation::internal()) catch err {
            defer err.free();
            return Err(err.to_string(fm));
        };
        let file_contents = included_file.file_contents.unwrap();
        defer file_contents.free();
        let tokens = Lexer::lex(included_file.file_index, file_contents) catch err {
            defer err.free();
            return Err(err.to_string(fm));
        };
        defer tokens.free();
        let ast = Parser::parse(tokens) catch err {
            defer err.free();
            return Err(err.to_string(fm));
        };
        defer ast.free();
        stdout_enable_buffering();
        Printer::print(ast);
        return Ok();
    };
    if compiler_mode == CompilerMode::EvalWasm {
        let module_bytes = file_read(file_name)?;
        defer module_bytes.free();
        let wasm_module = WasmParser::parse(String::from_str(file_name), module_bytes)?;
        defer wasm_module.free();
        WasmEval::eval(wasm_module) catch err {
            defer heap::free(err);
            return Err(err.message);
        };
        return Ok();
    };
    if compiler_mode == CompilerMode::Inspect {
        stdout_enable_buffering();
    };
    let codegen = CodeGen::new(compiler_mode);
    defer codegen.free();
    let included_file = codegen.fm.include_file(file_name, LoLocation::internal()) catch err {
        defer err.free();
        return Err(err.to_string(codegen.fm));
    };
    let asts = Vec::new!<AST>();
    defer asts.free_deep!<AST>();
    parse_file_tree(compiler_mode, codegen.fm, asts, included_file.file_index, included_file.file_contents.unwrap()) catch err {
        return err.to_string(codegen.fm);
    };
    for i in 0..asts.size {
        let ast = asts.get!<AST>(i);
        codegen.process_file(ast) catch err {
            defer err.free();
            return err.to_string(codegen.fm);
        };
    };
    codegen.errors.print_all(codegen.fm)?;
    let wasm_module = codegen.generate() catch err {
        defer err.free();
        return err.to_string(codegen.fm);
    };
    defer wasm_module.free();
    if compiler_mode == CompilerMode::Compile {
        let binary = String::new(16);
        defer binary.free();
        wasm_module.dump(binary);
        stdout_write(binary.as_str());
    };
    if compiler_mode == CompilerMode::Eval {
        WasmEval::eval(wasm_module) catch err {
            return Err(err.message);
        };
    };
    return Ok();
};

fn parse_file_tree(mode: CompilerMode, fm: &FileManager, asts: &Vec of AST, file_index: u32, file_contents: String): Result<void, &LoError> {
    if mode == CompilerMode::Inspect {
        // TODO: port
        // let file_path = fm.get_file_path(file_index);
        // stdout_writeln(format!(
        //     "{{ \"type\": \"file\", \
        //         \"index\": {file_index}, \
        //         \"path\": \"{file_path}\" }}, ",
        // ));
    };
    let tokens = Lexer::lex(file_index, file_contents)?;
    let ast = Parser::parse(tokens)?;
    for i in 0..ast.exprs.size {
        // TODO: port
        // let expr = ast.exprs.get!<TopLevelExpr>(i);
        // let TopLevelExpr::Include(include) = expr else {
        //     continue;
        // };
        // let included_file = fm.include_file(include.file_path.unescape(), include.loc)?;
        // if let Some(file_contents) = included_file.file_contents {
        //     parse_file_tree(mode, fm, asts, included_file.file_index, file_contents)?;
        // }
        // if mode == CompilerMode::Inspect {
        //     let source_index = file_index;
        //     let source_range = RangeDisplay(&include.loc);
        //     let target_index = included_file.file_index;
        //     let target_range = "1:1-1:1";
        //     stdout_writeln(format!(
        //         "{{ \"type\": \"info\", \
        //             \"link\": \"{target_index}/{target_range}\", \
        //             \"loc\": \"{source_index}/{source_range}\" }}, ",
        //     ));
        // };
    };
    asts.push!(ast);
    return Ok();
};
