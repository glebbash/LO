include "./core.lo"
include "./ast.lo"
include "./wasm.lo"
include "./codegen.lo"
include "./lexer.lo"
include "./parser.lo"
include "./printer.lo"
include "./wasm_eval.lo"
include "./wasm_parser.lo"

export memory {
    min_pages: 1,
}

const USAGE = "Usage:
  lo compile <input.lo>
  lo inspect <input.lo>
  lo format <input.lo>
  lo eval <input.lo> (experimental)
  lo wasi <input.lo> (experimental)"

export fn _start() {
    let args = Args::load()
    defer args.free()
    if args.argc < 3 {
        stderr_writeln(USAGE)
        return finalize_and_exit(1)
    }

    let command = LoCommand::Compile
    let command_arg = args.get(1)
    if command_arg.equals("compile") {
        command = LoCommand::Compile
    } else if command_arg.equals("inspect") {
        command = LoCommand::Inspect
    } else if command_arg.equals("format") {
        command = LoCommand::Format
    } else if command_arg.equals("eval") {
        command = LoCommand::Eval
    } else if command_arg.equals("wasi") {
        command = LoCommand::Wasi
    } else {
        stderr_write("Unknown command: ")
        stderr_writeln(command_arg)
        stderr_writeln(USAGE)
        return finalize_and_exit(1)
    }

    let file_name = args.get(2)
    if file_name.equals("-i") {
        file_name = "<stdin>"
    }

    if command == LoCommand::Format {
        let codegen = CodeGen::new(command)
        defer codegen.free()
        let asts = Vec::new!<AST>()
        defer asts.free_deep!<AST>()

        // in format mode `pass_parse_files_rec` only parses a single AST (or none if lexing failed)
        codegen.pass_parse_files_rec(asts, file_name, LoLocation::internal())
        if asts.size == 0 {
            return finalize_and_exit(1)
        }
        let ast = asts.get!<AST>(0)

        stdout_enable_buffering()
        Printer::print(ast)

        return finalize_and_exit(0)
    }

    if command == LoCommand::Wasi {
        let module_bytes = file_read(file_name) catch err {
            defer err.free()
            stderr_writeln(err.as_str())
            return finalize_and_exit(1)
        }

        let wasm_module = WasmParser::parse(String::from_str(file_name), module_bytes) catch err {
            defer err.free()
            stderr_writeln(err.as_str())
            return finalize_and_exit(1)
        }
        defer wasm_module.free()

        WasmEval::eval(wasm_module) catch err {
            defer err.free()
            stderr_writeln(err.message.as_str())
            return finalize_and_exit(1)
        }

        return finalize_and_exit(0)
    }

    if command == LoCommand::Inspect {
        stdout_enable_buffering()
    }

    let codegen = CodeGen::new(command)
    defer codegen.free()

    let asts = Vec::new!<AST>()
    defer asts.free_deep!<AST>()

    codegen.pass_parse_files_rec(asts, file_name, LoLocation::internal())

    for i in 0..asts.size {
        let ast = asts.at!<AST>(i)
        codegen.pass_collect_typedefs(ast)
    }

    for i in 0..asts.size {
        let ast = asts.at!<AST>(i)
        codegen.pass_build_structs(ast)
    }

    for i in 0..asts.size {
        let ast = asts.at!<AST>(i)
        codegen.pass_main(ast)
    }

    let wasm_module = WasmModule::new()
    defer wasm_module.free()

    codegen.generate(wasm_module)

    codegen.end_inspection()
    if codegen.error_count > 0 {
        return finalize_and_exit(1)
    }

    if command == LoCommand::Inspect {
        finalize_and_exit(0)
    }

    if command == LoCommand::Compile {
        let binary = String::new(16)
        defer binary.free()
        wasm_module.dump(binary)
        stdout_write(binary.as_str())
        return finalize_and_exit(0)
    }

    if command == LoCommand::Eval {
        WasmEval::eval(wasm_module) catch err {
            defer err.free()
            stderr_writeln(err.message.as_str())
            return finalize_and_exit(1)
        }
        return finalize_and_exit(0)
    }

    unreachable
}

fn finalize_and_exit(exit_code: u32): never {
    stdout_disable_buffering()
    proc_exit(exit_code)
}
