@include("./core.lo")
@include("./lexer.lo")

// TODO: impl proper cleanup for all &Vec fields here

type TopLevelExpr = enum (&void) {
    Let(&LetExpr),
    Fn(&FnExpr),
    Type(&TypeDefExpr),
    Intrinsic(&InlineFnCallExpr),
}

type IdentExpr = struct {
    repr: str,
    parts: &Vec(Loc),
    loc: Loc,
}

type FnDeclExpr = struct {
    fn_name: IdentExpr,
    type_params: &Vec(str),
    params: &Vec(FnParam),
    params_trailing_comma: bool,
    // @optional
    return_type: &TypeExpr,
    loc: Loc,
}

type FnExpr = struct {
    exported: bool,
    is_inline: bool,
    decl: FnDeclExpr,
    value: FnExprValue,
    loc: Loc,
}

type FnExprValue = enum (&void) {
    Body(&CodeBlock),
    ImportFrom(&QuotedString),
}

type FnParam = struct {
    param_name: IdentExpr,
    param_type: FnParamType,
    loc: Loc,
}

type FnParamType = enum (&void) {
    Self(&void),
    SelfRef(&void),
    Type(&FnParamTypeType),
    Infer(&FnParamTypeInfer),
}

type FnParamTypeType = struct {
    expr: TypeExpr,
}

type FnParamTypeInfer = struct {
    name: str,
}

type LetExpr = struct {
    is_inline: bool,
    name: IdentExpr,
    value: CodeExpr,
    loc: Loc,
}

type TypeDefExpr = struct {
    name: IdentExpr,
    value: TypeDefValue,
    loc: Loc,
}

type TypeDefValue = enum (&void) {
    Struct(&TypeDefValueStruct),
    Enum(&TypeDefValueEnum),
    Alias(&TypeExpr),
}

type TypeDefValueStruct = struct {
    fields: &Vec(StructDefField),
}

type StructDefField = struct {
    field_name: IdentExpr,
    field_type: TypeExpr,
    loc: Loc,
}

type TypeDefValueEnum = struct {
    // @optional
    variant_type: &TypeExpr,
    variants: &Vec(EnumDefVariant),
}

type EnumDefVariant = struct {
    variant_name: IdentExpr,
    // @optional
    variant_type: &TypeExpr,
    loc: Loc,
}

type CodeExprMap = struct {
    fields: &Vec(CodeExprMapField),
    has_trailing_comma: bool,
    loc: Loc,
}

type CodeBlock = struct {
    exprs: &Vec(CodeExpr),
    loc: Loc,
}

fn TopLevelExpr::loc(self): Loc {
    if match TopLevelExpr::Fn(e) = self {
        return e.loc
    }
    if match TopLevelExpr::Let(e) = self {
        return e.loc
    }
    if match TopLevelExpr::Type(e) = self {
        return e.loc
    }
    if match TopLevelExpr::Intrinsic(e) = self {
        return e.loc
    }
    @unreachable()
}

type TypeExpr = enum (&void) {
    Named(&TypeExprNamed),
    Pointer(&TypeExprPointer),
    SequencePointer(&TypeExprSequencePointer),
    Container(&TypeExprContainer),
}

fn TypeExpr::loc(self): Loc {
    if match TypeExpr::Named(e) = self {
        return e.name.loc
    }
    if match TypeExpr::Pointer(e) = self {
        return e.loc
    }
    if match TypeExpr::SequencePointer(e) = self {
        return e.loc
    }
    if match TypeExpr::Container(e) = self {
        return e.loc
    }
    @unreachable()
}

type TypeExprNamed = struct {
    name: IdentExpr,
}

type TypeExprPointer = struct {
    pointee: TypeExpr,
    loc: Loc,
}

type TypeExprSequencePointer = struct {
    pointee: TypeExpr,
    loc: Loc,
}

type TypeExprContainer = struct {
    container: TypeExpr,
    items: &Vec(TypeExpr),
    loc: Loc,
}

type CodeExpr = enum (&void) {
    // literals
    BoolLiteral(&BoolLiteralExpr),
    CharLiteral(&CharLiteralExpr),
    NullLiteral(&NullLiteralExpr),
    IntLiteral(&IntLiteralExpr),
    StringLiteral(&StringLiteralExpr),
    StructLiteral(&StructLiteralExpr),
    ArrayLiteral(&ArrayLiteralExpr),
    ResultLiteral(&ResultLiteralExpr),

    // variables
    Ident(&IdentExpr),
    Let(&LetExpr),

    // operations
    InfixOp(&InfixOpExpr),
    PrefixOp(&PrefixOpExpr),
    Cast(&CastExpr),
    Assign(&AssignExpr),
    FieldAccess(&FieldAccessExpr),
    PropagateError(&PropagateErrorExpr),
    FnCall(&FnCallExpr),
    MethodCall(&MethodCallExpr),
    InlineFnCall(&InlineFnCallExpr),
    InlineFnMethodCall(&InlineFnMethodCallExpr),
    IntrinsicCall(&InlineFnCallExpr),

    // control flow
    Return(&ReturnExpr),
    If(&IfExpr),
    While(&WhileExpr),
    For(&ForExpr),
    Break(&BreakExpr),
    Continue(&ContinueExpr),
    Defer(&DeferExpr),
    Catch(&CatchExpr),
    Match(&MatchExpr),

    // other
    Paren(&ParenExpr),
    DoWith(&DoWithExpr),
    ExprPipe(&ExprPipeExpr),
    Sizeof(&SizeofExpr),
}

type BoolLiteralExpr = struct {
    value: bool,
    loc: Loc,
}

type CharLiteralExpr = struct {
    repr: str,
    value: u32,
    loc: Loc,
}

type NullLiteralExpr = struct {
    loc: Loc,
}

type IntLiteralExpr = struct {
    repr: str,
    value: i64,
    // @optional
    tag: &str,
    loc: Loc,
}

type StringLiteralExpr = struct {
    repr: str,
    value: String,
    loc: Loc,
}

type ReturnExpr = struct {
    // @optional
    expr: &CodeExpr,
    loc: Loc,
}

type InfixOpExpr = struct {
    op_tag: InfixOpTag,
    op_loc: Loc,
    lhs: CodeExpr,
    rhs: CodeExpr,
    loc: Loc,
}

type PrefixOpExpr = struct {
    op_tag: PrefixOpTag,
    expr: CodeExpr,
    op_loc: Loc,
    loc: Loc,
}

type IfExpr = struct {
    cond: IfCond,
    then_block: CodeBlock,
    else_block: ElseBlock,
    loc: Loc,
}

type IfCond = enum (&void) {
    Expr(&CodeExpr),
    Match(&MatchHeader),
}

type MatchHeader = struct {
    variant_name: IdentExpr,
    variant_bind: IdentExpr,
    expr_to_match: CodeExpr,
}

type ElseBlock = enum (&void) {
    None(&void),
    Else(&CodeBlock),
    ElseIf(&CodeExpr),
}

type WhileExpr = struct {
    // @optional
    cond: &CodeExpr,
    body: CodeBlock,
    loc: Loc,
}

type BreakExpr = struct {
    loc: Loc,
}

type ForExpr = struct {
    counter: IdentExpr,
    start: CodeExpr,
    end: CodeExpr,
    body: CodeBlock,
    op_loc: Loc,
    loc: Loc,
}

type ContinueExpr = struct {
    loc: Loc,
}

type CodeExprList = struct {
    items: &Vec(CodeExpr),
    has_trailing_comma: bool,
}

type DoWithExpr = struct {
    body: CodeExpr,
    args: CodeExprList,
    with_loc: Loc,
    loc: Loc,
}

type ExprPipeExpr = struct {
    lhs: CodeExpr,
    rhs: CodeExpr,
    op_loc: Loc,
    loc: Loc,
}

type DeferExpr = struct {
    expr: CodeExpr,
    loc: Loc,
}

type CastExpr = struct {
    expr: CodeExpr,
    casted_to: TypeExpr,
    loc: Loc,
}

type StructLiteralExpr = struct {
    struct_name: IdentExpr,
    body: CodeExprMap,
    loc: Loc,
}

type ArrayLiteralExpr = struct {
    item_type: TypeExpr,
    items: &Vec(CodeExpr),
    has_trailing_comma: bool,
    loc: Loc,
}

type ResultLiteralExpr = struct {
    is_ok: bool,
    // @optional
    result_type: &ResultTypeExpr,
    // @optional
    value: &CodeExpr,
    loc: Loc,
}

type ResultTypeExpr = struct {
    ok: TypeExpr,
    err: TypeExpr,
}

type CodeExprMapField = struct {
    key: str,
    value: CodeExpr,
    loc: Loc,
}

type AssignExpr = struct {
    op_loc: Loc,
    lhs: CodeExpr,
    rhs: CodeExpr,
    loc: Loc,
}

type FieldAccessExpr = struct {
    lhs: CodeExpr,
    field_name: IdentExpr,
    loc: Loc,
}

type CatchExpr = struct {
    lhs: CodeExpr,
    error_bind: IdentExpr,
    catch_body: CodeBlock,
    catch_loc: Loc,
    loc: Loc,
}

type MatchExpr = struct {
    header: MatchHeader,
    else_branch: CodeBlock,
    loc: Loc,
}

type PropagateErrorExpr = struct {
    expr: CodeExpr,
    loc: Loc,
}

type ParenExpr = struct {
    expr: CodeExpr,
    has_trailing_comma: bool,
    loc: Loc,
}

type FnCallExpr = struct {
    fn_name: IdentExpr,
    args: CodeExprList,
    loc: Loc,
}

type MethodCallExpr = struct {
    lhs: CodeExpr,
    field_name: IdentExpr,
    args: CodeExprList,
    loc: Loc,
}

type InlineFnCallExpr = struct {
    fn_name: IdentExpr,
    type_args: &Vec(TypeExpr),
    args: CodeExprList,
    loc: Loc,
}

type InlineFnMethodCallExpr = struct {
    lhs: CodeExpr,
    field_name: IdentExpr,
    type_args: &Vec(TypeExpr),
    args: CodeExprList,
    loc: Loc,
}

type SizeofExpr = struct {
    type_expr: TypeExpr,
    loc: Loc,
}

fn CodeExpr::loc(self): Loc {
    if match CodeExpr::BoolLiteral(e) = self {
        return e.loc
    }
    if match CodeExpr::CharLiteral(e) = self {
        return e.loc
    }
    if match CodeExpr::NullLiteral(e) = self {
        return e.loc
    }
    if match CodeExpr::IntLiteral(e) = self {
        return e.loc
    }
    if match CodeExpr::StringLiteral(e) = self {
        return e.loc
    }
    if match CodeExpr::ArrayLiteral(e) = self {
        return e.loc
    }
    if match CodeExpr::ResultLiteral(e) = self {
        return e.loc
    }
    if match CodeExpr::Return(e) = self {
        return e.loc
    }
    if match CodeExpr::Ident(e) = self {
        return e.loc
    }
    if match CodeExpr::InfixOp(e) = self {
        return e.loc
    }
    if match CodeExpr::If(e) = self {
        return e.loc
    }
    if match CodeExpr::Let(e) = self {
        return e.loc
    }
    if match CodeExpr::While(e) = self {
        return e.loc
    }
    if match CodeExpr::Break(e) = self {
        return e.loc
    }
    if match CodeExpr::For(e) = self {
        return e.loc
    }
    if match CodeExpr::Continue(e) = self {
        return e.loc
    }
    if match CodeExpr::Defer(e) = self {
        return e.loc
    }
    if match CodeExpr::Cast(e) = self {
        return e.loc
    }
    if match CodeExpr::StructLiteral(e) = self {
        return e.loc
    }
    if match CodeExpr::Assign(e) = self {
        return e.loc
    }
    if match CodeExpr::FieldAccess(e) = self {
        return e.loc
    }
    if match CodeExpr::Catch(e) = self {
        return e.loc
    }
    if match CodeExpr::Match(e) = self {
        return e.loc
    }
    if match CodeExpr::Paren(e) = self {
        return e.loc
    }
    if match CodeExpr::FnCall(e) = self {
        return e.loc
    }
    if match CodeExpr::MethodCall(e) = self {
        return e.loc
    }
    if match CodeExpr::InlineFnCall(e) = self {
        return e.loc
    }
    if match CodeExpr::IntrinsicCall(e) = self {
        return e.loc
    }
    if match CodeExpr::InlineFnMethodCall(e) = self {
        return e.loc
    }
    if match CodeExpr::Sizeof(e) = self {
        return e.loc
    }
    if match CodeExpr::PropagateError(e) = self {
        return e.loc
    }
    if match CodeExpr::PrefixOp(e) = self {
        return e.loc
    }
    if match CodeExpr::DoWith(e) = self {
        return e.loc
    }
    if match CodeExpr::ExprPipe(e) = self {
        return e.loc
    }
    @unreachable()
}
