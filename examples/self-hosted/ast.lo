include "./core.lo"
include "./lexer.lo"

// TODO: impl proper cleanup for all &Vec fields here

type TopLevelExpr = enum(&void) {
    FnDef(&FnDefExpr),
    Include(&IncludeExpr),
    Import(&ImportExpr),
    GlobalDef(&GlobalDefExpr),
    StructDef(&StructDefExpr),
    EnumDef(&EnumDefExpr),
    TypeDef(&TypeDefExpr),
    ConstDef(&ConstDefExpr),
    MemoryDef(&MemoryDefExpr),
    InlineFnDef(&InlineFnDefExpr),
    IntrinsicCall(&InlineFnFnCallExpr),
}

type IdentExpr = struct {
    repr: str,
    parts: &Vec(Loc),
    loc: Loc,
}

type FnDeclExpr = struct {
    fn_name: IdentExpr,
    fn_params: &Vec(FnParam),
    fn_params_trailing_comma: bool,
    // @optional
    return_type: &TypeExpr,
    loc: Loc,
}

type FnDefExpr = struct {
    exported: bool,
    decl: FnDeclExpr,
    // NOTE: this is ref only cause CodeBlock isn't defined at this point
    body: &CodeBlock,
    loc: Loc,
}

type FnParam = struct {
    param_name: IdentExpr,
    param_type: FnParamType,
    loc: Loc,
}

type FnParamType = enum(&void) {
    Self(&void),
    SelfRef(&void),
    Type(&FnParamTypeType),
    Infer(&FnParamTypeInfer),
}

type FnParamTypeType = struct {
    expr: TypeExpr,
}

type FnParamTypeInfer = struct {
    name: str,
}

/// DOC: `include "<module path>" [as <alias>] [with extern]` syntax was chosen
///   because it reuses existing rust keywords and reads nicely (mostly).
///
/// Another option was `import "..." [as ...] [and expose]`
///   but `import` is already a WASM concept and `and expose` is two new keywords for just one flag

type IncludeExpr = struct {
    file_path: QuotedString,
    // @optional
    alias: &IdentExpr,
    with_extern: bool,
    loc: Loc,
}

type ImportExpr = struct {
    module_name: QuotedString,
    items: &Vec(ImportItem),
    loc: Loc,
}

type ImportItem = enum(&void) {
    FnDecl(&FnDeclExpr),
    Memory(&MemoryDefExpr),
}

fn ImportItem::loc(self): Loc {
    if match ImportItem::FnDecl(e) = self {
        return e.loc
    }
    if match ImportItem::Memory(e) = self {
        return e.loc
    }
    @unreachable()
}

type GlobalDefExpr = struct {
    global_name: IdentExpr,
    global_value: CodeExpr,
    loc: Loc,
}

type StructDefExpr = struct {
    struct_name: IdentExpr,
    fields: &Vec(StructDefField),
    loc: Loc,
}

type StructDefField = struct {
    field_name: IdentExpr,
    field_type: TypeExpr,
    loc: Loc,
}

type EnumDefExpr = struct {
    enum_name: IdentExpr,
    // @optional
    variant_type: &TypeExpr,
    variants: &Vec(EnumDefVariant),
    loc: Loc,
}

type EnumDefVariant = struct {
    variant_name: IdentExpr,
    // @optional
    variant_type: &TypeExpr,
    loc: Loc,
}

type TypeDefExpr = struct {
    type_name: IdentExpr,
    type_value: TypeExpr,
    loc: Loc,
}

type ConstDefExpr = struct {
    const_name: IdentExpr,
    const_value: CodeExpr,
    loc: Loc,
}

type CodeExprMap = struct {
    fields: &Vec(CodeExprMapField),
    has_trailing_comma: bool,
    loc: Loc,
}

type MemoryDefExpr = struct {
    exported: bool,
    params: CodeExprMap,
    loc: Loc,
}

type CodeBlock = struct {
    exprs: &Vec(CodeExpr),
    loc: Loc,
}

type InlineFnDefExpr = struct {
    inline_fn_name: IdentExpr,
    params: &Vec(FnParam),
    params_trailing_comma: bool,
    type_params: &Vec(str),
    // @optional
    return_type: &TypeExpr,
    body: CodeBlock,
    loc: Loc,
}

fn TopLevelExpr::loc(self): Loc {
    if match TopLevelExpr::FnDef(e) = self {
        return e.loc
    }
    if match TopLevelExpr::Include(e) = self {
        return e.loc
    }
    if match TopLevelExpr::Import(e) = self {
        return e.loc
    }
    if match TopLevelExpr::GlobalDef(e) = self {
        return e.loc
    }
    if match TopLevelExpr::StructDef(e) = self {
        return e.loc
    }
    if match TopLevelExpr::EnumDef(e) = self {
        return e.loc
    }
    if match TopLevelExpr::TypeDef(e) = self {
        return e.loc
    }
    if match TopLevelExpr::ConstDef(e) = self {
        return e.loc
    }
    if match TopLevelExpr::MemoryDef(e) = self {
        return e.loc
    }
    if match TopLevelExpr::InlineFnDef(e) = self {
        return e.loc
    }
    if match TopLevelExpr::IntrinsicCall(e) = self {
        return e.loc
    }
    @unreachable()
}

type TypeExpr = enum(&void) {
    Named(&TypeExprNamed),
    Pointer(&TypeExprPointer),
    SequencePointer(&TypeExprSequencePointer),
    Container(&TypeExprContainer),
}

fn TypeExpr::loc(self): Loc {
    if match TypeExpr::Named(e) = self {
        return e.name.loc
    }
    if match TypeExpr::Pointer(e) = self {
        return e.loc
    }
    if match TypeExpr::SequencePointer(e) = self {
        return e.loc
    }
    if match TypeExpr::Container(e) = self {
        return e.loc
    }
    @unreachable()
}

type TypeExprNamed = struct {
    name: IdentExpr,
}

type TypeExprPointer = struct {
    pointee: TypeExpr,
    loc: Loc,
}

type TypeExprSequencePointer = struct {
    pointee: TypeExpr,
    loc: Loc,
}

type TypeExprContainer = struct {
    container: TypeExpr,
    items: &Vec(TypeExpr),
    loc: Loc,
}

type CodeExpr = enum(&void) {
    // literals
    BoolLiteral(&BoolLiteralExpr),
    CharLiteral(&CharLiteralExpr),
    NullLiteral(&NullLiteralExpr),
    IntLiteral(&IntLiteralExpr),
    StringLiteral(&StringLiteralExpr),
    StructLiteral(&StructLiteralExpr),
    ArrayLiteral(&ArrayLiteralExpr),
    ResultLiteral(&ResultLiteralExpr),

    // variables
    Ident(&IdentExpr),
    Let(&LetExpr),

    // operations
    InfixOp(&InfixOpExpr),
    PrefixOp(&PrefixOpExpr),
    Cast(&CastExpr),
    Assign(&AssignExpr),
    FieldAccess(&FieldAccessExpr),
    PropagateError(&PropagateErrorExpr),
    FnCall(&FnCallExpr),
    MethodCall(&MethodCallExpr),
    InlineFnFnCall(&InlineFnFnCallExpr),
    InlineFnMethodCall(&InlineFnMethodCallExpr),
    IntrinsicCall(&InlineFnFnCallExpr),

    // control flow
    Return(&ReturnExpr),
    If(&IfExpr),
    While(&WhileExpr),
    For(&ForExpr),
    Break(&BreakExpr),
    Continue(&ContinueExpr),
    Defer(&DeferExpr),
    Catch(&CatchExpr),
    Match(&MatchExpr),

    // other
    Paren(&ParenExpr),
    DoWith(&DoWithExpr),
    ExprPipe(&ExprPipeExpr),
    Sizeof(&SizeofExpr),
}

type BoolLiteralExpr = struct {
    value: bool,
    loc: Loc,
}

type CharLiteralExpr = struct {
    repr: str,
    value: u32,
    loc: Loc,
}

type NullLiteralExpr = struct {
    loc: Loc,
}

type IntLiteralExpr = struct {
    repr: str,
    value: i64,
    // @optional
    tag: &str,
    loc: Loc,
}

type StringLiteralExpr = struct {
    repr: str,
    value: String,
    loc: Loc,
}

type ReturnExpr = struct {
    // @optional
    expr: &CodeExpr,
    loc: Loc,
}

type InfixOpExpr = struct {
    op_tag: InfixOpTag,
    op_loc: Loc,
    lhs: CodeExpr,
    rhs: CodeExpr,
    loc: Loc,
}

type PrefixOpExpr = struct {
    op_tag: PrefixOpTag,
    expr: CodeExpr,
    op_loc: Loc,
    loc: Loc,
}

type IfExpr = struct {
    cond: IfCond,
    then_block: CodeBlock,
    else_block: ElseBlock,
    loc: Loc,
}

type IfCond = enum(&void) {
    Expr(&CodeExpr),
    Match(&MatchHeader),
}

type MatchHeader = struct {
    variant_name: IdentExpr,
    variant_bind: IdentExpr,
    expr_to_match: CodeExpr,
}

type ElseBlock = enum(&void) {
    None(&void),
    Else(&CodeBlock),
    ElseIf(&CodeExpr),
}

type LetExpr = struct {
    local_name: IdentExpr,
    value: CodeExpr,
    loc: Loc,
}

type WhileExpr = struct {
    // @optional
    cond: &CodeExpr,
    body: CodeBlock,
    loc: Loc,
}

type BreakExpr = struct {
    loc: Loc,
}

type ForExpr = struct {
    counter: IdentExpr,
    start: CodeExpr,
    end: CodeExpr,
    body: CodeBlock,
    op_loc: Loc,
    loc: Loc,
}

type ContinueExpr = struct {
    loc: Loc,
}

type CodeExprList = struct {
    items: &Vec(CodeExpr),
    has_trailing_comma: bool,
}

type DoWithExpr = struct {
    body: CodeExpr,
    args: CodeExprList,
    with_loc: Loc,
    loc: Loc,
}

type ExprPipeExpr = struct {
    lhs: CodeExpr,
    rhs: CodeExpr,
    op_loc: Loc,
    loc: Loc,
}

type DeferExpr = struct {
    expr: CodeExpr,
    loc: Loc,
}

type CastExpr = struct {
    expr: CodeExpr,
    casted_to: TypeExpr,
    loc: Loc,
}

type StructLiteralExpr = struct {
    struct_name: IdentExpr,
    body: CodeExprMap,
    loc: Loc,
}

type ArrayLiteralExpr = struct {
    item_type: TypeExpr,
    items: &Vec(CodeExpr),
    has_trailing_comma: bool,
    loc: Loc,
}

type ResultLiteralExpr = struct {
    is_ok: bool,
    // @optional
    result_type: &ResultTypeExpr,
    // @optional
    value: &CodeExpr,
    loc: Loc,
}

type ResultTypeExpr = struct {
    ok: TypeExpr,
    err: TypeExpr,
}

type CodeExprMapField = struct {
    key: str,
    value: CodeExpr,
    loc: Loc,
}

type AssignExpr = struct {
    op_loc: Loc,
    lhs: CodeExpr,
    rhs: CodeExpr,
    loc: Loc,
}

type FieldAccessExpr = struct {
    lhs: CodeExpr,
    field_name: IdentExpr,
    loc: Loc,
}

type CatchExpr = struct {
    lhs: CodeExpr,
    error_bind: IdentExpr,
    catch_body: CodeBlock,
    catch_loc: Loc,
    loc: Loc,
}

type MatchExpr = struct {
    header: MatchHeader,
    else_branch: CodeBlock,
    loc: Loc,
}

type PropagateErrorExpr = struct {
    expr: CodeExpr,
    loc: Loc,
}

type ParenExpr = struct {
    expr: CodeExpr,
    has_trailing_comma: bool,
    loc: Loc,
}

type FnCallExpr = struct {
    fn_name: IdentExpr,
    args: CodeExprList,
    loc: Loc,
}

type MethodCallExpr = struct {
    lhs: CodeExpr,
    field_name: IdentExpr,
    args: CodeExprList,
    loc: Loc,
}

type InlineFnFnCallExpr = struct {
    fn_name: IdentExpr,
    type_args: &Vec(TypeExpr),
    args: CodeExprList,
    loc: Loc,
}

type InlineFnMethodCallExpr = struct {
    lhs: CodeExpr,
    field_name: IdentExpr,
    type_args: &Vec(TypeExpr),
    args: CodeExprList,
    loc: Loc,
}

type SizeofExpr = struct {
    type_expr: TypeExpr,
    loc: Loc,
}

fn CodeExpr::loc(self): Loc {
    if match CodeExpr::BoolLiteral(e) = self {
        return e.loc
    }
    if match CodeExpr::CharLiteral(e) = self {
        return e.loc
    }
    if match CodeExpr::NullLiteral(e) = self {
        return e.loc
    }
    if match CodeExpr::IntLiteral(e) = self {
        return e.loc
    }
    if match CodeExpr::StringLiteral(e) = self {
        return e.loc
    }
    if match CodeExpr::ArrayLiteral(e) = self {
        return e.loc
    }
    if match CodeExpr::ResultLiteral(e) = self {
        return e.loc
    }
    if match CodeExpr::Return(e) = self {
        return e.loc
    }
    if match CodeExpr::Ident(e) = self {
        return e.loc
    }
    if match CodeExpr::InfixOp(e) = self {
        return e.loc
    }
    if match CodeExpr::If(e) = self {
        return e.loc
    }
    if match CodeExpr::Let(e) = self {
        return e.loc
    }
    if match CodeExpr::While(e) = self {
        return e.loc
    }
    if match CodeExpr::Break(e) = self {
        return e.loc
    }
    if match CodeExpr::For(e) = self {
        return e.loc
    }
    if match CodeExpr::Continue(e) = self {
        return e.loc
    }
    if match CodeExpr::Defer(e) = self {
        return e.loc
    }
    if match CodeExpr::Cast(e) = self {
        return e.loc
    }
    if match CodeExpr::StructLiteral(e) = self {
        return e.loc
    }
    if match CodeExpr::Assign(e) = self {
        return e.loc
    }
    if match CodeExpr::FieldAccess(e) = self {
        return e.loc
    }
    if match CodeExpr::Catch(e) = self {
        return e.loc
    }
    if match CodeExpr::Match(e) = self {
        return e.loc
    }
    if match CodeExpr::Paren(e) = self {
        return e.loc
    }
    if match CodeExpr::FnCall(e) = self {
        return e.loc
    }
    if match CodeExpr::MethodCall(e) = self {
        return e.loc
    }
    if match CodeExpr::InlineFnFnCall(e) = self {
        return e.loc
    }
    if match CodeExpr::IntrinsicCall(e) = self {
        return e.loc
    }
    if match CodeExpr::InlineFnMethodCall(e) = self {
        return e.loc
    }
    if match CodeExpr::Sizeof(e) = self {
        return e.loc
    }
    if match CodeExpr::PropagateError(e) = self {
        return e.loc
    }
    if match CodeExpr::PrefixOp(e) = self {
        return e.loc
    }
    if match CodeExpr::DoWith(e) = self {
        return e.loc
    }
    if match CodeExpr::ExprPipe(e) = self {
        return e.loc
    }
    @unreachable()
}
