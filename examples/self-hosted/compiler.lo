include "./core.lo"
include "./lexer.lo"
include "./parser.lo"

struct Module {
    error_arena: &Arena,
    parser: &Parser,
}

fn Module::new(parser: &Parser): &Module {
    return heap::new!(Module {
        error_arena: parser.error_arena,
        parser: parser,
    })
}

fn Module::free(&self) {
    self.parser.lexer.free()
    self.parser.free()
}

struct Compiler {
    in_single_file_mode: bool,
    in_lex_only_mode: bool,

    fm: FileManager,
    modules: &Vec(&Module),
    error_arena: &Arena,
}

fn Compiler::new(): &Compiler {
    let error_arena = Arena::new(128)

    return heap::new!(Compiler {
        in_single_file_mode: false,
        in_lex_only_mode: false,
        fm: FileManager::new(error_arena),
        modules: Vec::new!<&Module>(),
        error_arena: error_arena,
    })
}

fn Compiler::free(&self) {
    self.fm.free()
    self.modules.free_deep!<&Module>()
    self.error_arena.free()
    heap::free(self)
}

fn Compiler::include(
    &self, \\ file_name: str, \\ loc: &Loc,
): Result(&Module, &VoidError) {
    let file_index = self.fm.include(file_name, loc) catch err {
        self.report_error(err)
        return Err(VoidError::VALUE)
    }

    let source = self.fm.get(file_index).source.as_str()

    let lexer = Lexer::new(self.error_arena, source, file_index)
    lexer.lex_file() catch err {
        self.report_error(err)
        return Err(VoidError::VALUE)
    }

    let parser = Parser::new(lexer)
    if !self.in_lex_only_mode {
        parser.parse_file() catch err {
            self.report_error(err)
            return Err(VoidError::VALUE)
        }
    }

    let module = Module::new(parser)
    self.modules.push!(module)

    return Ok(module)
}

fn Compiler::report_error(&self, err: &Error) {
    stderr_write("ERROR: ")
    stderr_write(err.to_string_in(self.error_arena, self.fm).as_str())
    stderr_write("\n")
}
