include "../lib/wasi.lo"
include "../lib/args.lo"
// tmp, for use in `std*_write` functions
include "../lib/print.lo"

// TODO: implement the module
type LoCommand = u8

const LoCommand::Compile = 0 as u8
const LoCommand::Inspect = 1 as u8
const LoCommand::Format = 2 as u8
const LoCommand::Eval = 3 as u8
const LoCommand::Wasi = 4 as u8

struct LoPosition {
    offset: u32,
    line: u32,
    col: u32,
}

struct LoLocation {
    file_index: u32,
    pos: LoPosition,
    end_pos: LoPosition,
}

fn LoLocation::internal(): LoLocation {
    return .LoLocation {
        // internal
        file_index: 0,
        pos: .LoPosition { offset: 0, line: 1, col: 1 },
        end_pos: .LoPosition { offset: 0, line: 1, col: 1 },
    }
}

struct LoError {
    message: String,
    loc: LoLocation,
}

fn LoError::free(&self) {
    panic!(dbg "todo")
}

fn LoError::internal(message: str): &LoError {
    return heap::new!(.LoError {
        message: String::from_str(message),
        loc: LoLocation::internal(),
    })
}

fn LoError::to_string(&self, fm: &FileManager): String {
    panic!(dbg "todo")
}

macro panic!(message: str) {
    eputs(message)
    eputs("\n")
    unreachable
}

fn proc_exit(exit_code: u32) {
    wasi::proc_exit(exit_code)
}

fn file_read(file_path: str): Result<String, String> {
    panic!(dbg "todo")
}

global STDOUT_BUFFER = 0 as String

const STDOUT_BUFFER_SIZE = 4096

fn stdout_enable_buffering() {
    STDOUT_BUFFER = String::new(STDOUT_BUFFER_SIZE)
}

fn stdout_disable_buffering() {
    if STDOUT_BUFFER as u32 != 0 && STDOUT_BUFFER.len() > 0 {
        let _ = fputs(wasi::FD_STDOUT, STDOUT_BUFFER.as_str())
        STDOUT_BUFFER.chars.size = 0
    }
    STDOUT_BUFFER = 0 as String
}

fn stdout_writeln(message: str) {
    stdout_write(message)
    stdout_write("\n")
}

fn stdout_write(message: str) {
    if STDOUT_BUFFER as u32 == 0 {
        let _ = fputs(wasi::FD_STDOUT, message)
        return
    }
    //
    if STDOUT_BUFFER.len() + message.size > STDOUT_BUFFER_SIZE && STDOUT_BUFFER.len() > 0 {
        let _ = fputs(wasi::FD_STDOUT, STDOUT_BUFFER.as_str())
        STDOUT_BUFFER.chars.size = 0
    }
    //
    if message.size >= STDOUT_BUFFER_SIZE {
        let _ = fputs(wasi::FD_STDOUT, message)
        return
    }
    //
    STDOUT_BUFFER.push_str(message)
}

fn stderr_writeln(message: str) {
    stderr_write(message)
    stderr_write("\n")
}

fn stderr_write(message: str) {
    let _ = fputs(wasi::FD_STDERR, message)
}

struct FileInfo {
    file_index: u32,
    file_path: String,
}

struct FileManager {
    files: &Vec of FileInfo,
}

fn FileManager::new(): &FileManager {
    return heap::new!(.FileManager {
        files: Vec::new!<FileInfo>(),
    })
}

fn FileManager::free(&self) {
    panic!(dbg "todo")
}

// NOTE: this doesn't match Rust impl to not do extra String allocation and just print parts
//   mostly because freeing is cumbersome and not really about efficiency
fn FileManager::print_error(&self, err: &LoError) {
    panic!(err.message.as_str())
}

fn FileManager::get_file_path(&self, file_index: u32): str {
    return self.files.at!<FileInfo>(file_index).file_path.as_str()
}

struct OptionString {}

fn OptionString::unwrap(self): String {
    panic!(dbg "todo")
}

struct IncludedFile {
    file_index: u32,
    file_contents: OptionString,
}

fn FileManager::include_file(&self, file_name: str, loc: LoLocation): Result<IncludedFile, &LoError> {
    return Err(LoError::internal(dbg "todo"))
}
