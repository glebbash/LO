include "../lib/std.lo" with extern
include "../lib/fs.lo" with extern
include "../lib/wasi.lo"
include "../lib/print.lo"

type VoidError = u32
const VoidError::VALUE = 1 as &VoidError

struct Pos {
    offset: u32,
    line: u32,
    col: u32,
}

struct Loc {
    file_index: u32,
    pos: Pos,
    end_pos: Pos,
}

const Loc::FILE_INDEX_INTERNAL = 0

fn Loc::internal(): Loc {
    return Loc {
        file_index: Loc::FILE_INDEX_INTERNAL,
        pos: Pos { offset: 0, line: 1, col: 1 },
        end_pos: Pos { offset: 0, line: 1, col: 1 },
    }
}

fn Loc::format(self, out: String, fm: FileManager) {
    do out.push_str(it) with (
        fm.get(self.file_index).absolute_path.as_str(),
        ":", \\ self.pos.line.to_tmp_str!(),
        ":", \\ self.pos.col.to_tmp_str!(),
    )
}

fn Loc::to_string_in(self, a: Alloc, fm: FileManager): String {
    let out = String::new_in(a, 32)
    self.format(out, fm)
    return out
}

fn Loc::read_span(self, source: str): str {
    return source.slice(self.pos.offset, self.end_pos.offset)
}

struct Error {
    message: String,
    loc: Loc,
}

fn Error::to_string_in(&self, a: Alloc, fm: FileManager): String {
    let out = String::new_in(a, 32)
    self.loc.format(out, fm)
    out.push_str(" - ")
    out.push_str(self.message.as_str())
    return out
}

struct FileInfo {
    index: u32,
    included_times: u32,
    absolute_path: String,
    source: String,
}

fn FileInfo::free(self) {
    self.absolute_path.free()
    self.source.free()
}

struct FileManager {
    files: &Vec(FileInfo),
    error_arena: &Arena,
}

fn FileManager::new(error_arena: &Arena): FileManager {
    let files = Vec::new!<FileInfo>()
    files.push!(FileInfo {
        index: 0,
        included_times: 0,
        absolute_path: String::from_str("<internal>"),
        source: String::new(0),
    })
    return FileManager { files: files, error_arena: error_arena }
}

fn FileManager::get(self, file_index: u32): &FileInfo {
    return self.files.at!<FileInfo>(file_index)
}

fn FileManager::include(self, relative_path: str, loc: &Loc): Result(u32, &Error) {
    let parent_path = self.files.get!<FileInfo>(loc.file_index).absolute_path
    let absolute_path = resolve_path(relative_path, parent_path.as_str())

    let source = fs::read_file(absolute_path.as_str()) catch err {
        let message = String::new_in(self.error_arena, 64)
        do message.push_str(it) with (
            "Can't read file '", \\ absolute_path.as_str(), \\ "', error code = ",
            err.to_tmp_str!(),
        )

        return Err(self.error_arena.new!(Error {
            message: message,
            loc: Loc::internal(),
        }))
    }

    self.files.push!(FileInfo {
        index: self.files.size - 1,
        included_times: 1,
        absolute_path: absolute_path,
        source: source,
    })

    return Ok(self.files.size - 1)
}

fn FileManager::free(self) {
    self.files.free_deep!<FileInfo>()
}

fn resolve_path(file_path: str, relative_to: str): String {
    if !file_path.starts_with(".") {
        return String::from_str(file_path)
    }

    let path_items = relative_to.split('/', Vec::new!<str>())

    // remove filename
    path_items.pop()

    let _ = file_path.split('/', path_items)

    let normalized = Vec::new!<str>()
    defer normalized.free()

    for i in 0..path_items.size {
        let item = path_items.get!<str>(i)

        if item.equals(".") {
            continue
        }

        if item.equals("..") {
            if normalized.size > 0 {
                normalized.pop()
            }
            continue
        }

        normalized.push!(item)
    }

    return String::join(normalized, '/')
}

// utils

fn stderr_writeln(message: str) {
    stderr_write(message)
    stderr_write("\n")
}

fn stderr_write(message: str) {
    eprint(message)
}

global STDOUT_BUFFER = null as &Vec
const STDOUT_BUFFER_SIZE = 4096

fn stdout_enable_buffering() {
    STDOUT_BUFFER = Vec::with_capacity(STDOUT_BUFFER_SIZE, sizeof u8)
}

fn stdout_disable_buffering() {
    if STDOUT_BUFFER != null {
        if STDOUT_BUFFER.size != 0 {
            let _ = fprint_str(wasi::FD_STDOUT, STDOUT_BUFFER as &str)
        }
    }

    STDOUT_BUFFER.free()
    STDOUT_BUFFER = null
}

fn stdout_writeln(message: str) {
    stdout_write(message)
    stdout_write("\n")
}

fn stdout_write(message: str) {
    if STDOUT_BUFFER == null {
        print(message)
        return
    }

    if STDOUT_BUFFER.size + message.size > STDOUT_BUFFER_SIZE {
        if STDOUT_BUFFER.size != 0 {
            let _ = fprint_str(wasi::FD_STDOUT, STDOUT_BUFFER as &str)
            STDOUT_BUFFER.size = 0
        }
    }

    if message.size >= STDOUT_BUFFER_SIZE {
        print(message)
        return
    }

    STDOUT_BUFFER.push_all(message.data, message.size)
}
