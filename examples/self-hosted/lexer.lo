include "./core.lo"

struct Token {
    type_: TokenType,
    loc: Loc,
}

enum TokenType {
    StringLiteral,
    CharLiteral,
    IntLiteral,
    Symbol,
    Delim,
    Operator,
    Terminal,
}

fn TokenType::to_str(self): str {
    if self == TokenType::StringLiteral() {
        return "StringLiteral"
    } else if self == TokenType::CharLiteral() {
        return "CharLiteral"
    } else if self == TokenType::IntLiteral() {
        return "IntLiteral"
    } else if self == TokenType::Symbol() {
        return "Symbol"
    } else if self == TokenType::Delim() {
        return "Delim"
    } else if self == TokenType::Operator() {
        return "Operator"
    } else if self == TokenType::Terminal() {
        return "Terminal"
    } else {
        @unreachable()
    }
}

fn Token::get_value(&self, source: str): str {
    if self.is_terminal() {
        return "<EOF>"
    }

    return self.loc.read_span(source)
}

fn Token::is(&self, type_: TokenType, value: str, source: str): bool {
    return self.is_any(type_) && self.get_value(source).equals(value)
}

fn Token::is_any(&self, type_: TokenType): bool {
    return self.type_ == type_
}

fn Token::is_terminal(&self): bool {
    return self.is_any(TokenType::Terminal())
}

struct Lexer {
    // context
    source: str,
    file_index: u32,
    error_arena: &Arena,

    // state
    source_pos: Pos,
    current_char: Result<u32, UTF8ReadError>,
    was_newline: bool,

    // output
    tokens: &Vec of Token,
    comments: &Vec of Loc,
    backslashes: &Vec of Loc,
    double_backslashes: &Vec of Loc,
}

fn Lexer::new(error_arena: &Arena, source: str, file_index: u32): &Lexer {
    return heap::new!(Lexer {
        source: source,
        file_index: file_index,
        error_arena: error_arena,

        source_pos: Pos { offset: 0, line: 1, col: 1 },
        current_char: read_utf8_codepoint(source, 0),
        was_newline: false,

        tokens: Vec::new!<Token>(),
        comments: Vec::new!<Loc>(),
        backslashes: Vec::new!<Loc>(),
        double_backslashes: Vec::new!<Loc>(),
    })
}

fn Lexer::free(&self) {
    self.tokens.free()
    self.comments.free()
    self.backslashes.free()
    self.double_backslashes.free()
    heap::free(self)
}

fn Lexer::lex_file(&self): Result<void, &Error> {
    self.skip_space()

    while self.source_pos.offset < self.source.size {
        let token = self.lex_token()?
        self.tokens.push!(token)

        self.skip_space()
    }

    self.tokens.push!(Token {
        type_: TokenType::Terminal(),
        loc: self.loc(),
    })

    return Ok()
}

fn Lexer::lex_token(&self): Result<Token, &Error> {
    let char = self.current_char()? as u8

    if char == '\'' {
        return self.lex_char_literal()
    }

    if char == '"' {
        return self.lex_string_literal()
    }

    if char >= '0' && char <= '9' {
        return self.lex_int_literal()
    }

    // NOTE: must be after int check because it matches digits
    if Lexer::is_symbol_char(char) {
        return self.lex_symbol()
    }

    if Lexer::is_delim_char(char) {
        return self.lex_delim()
    }

    if Lexer::is_operator_start_char(char) {
        return self.lex_operator()
    }

    let message = String::from_str_in(self.error_arena, "Unexpected char: ")
    message.push(char)

    return Err(self.error_arena.new!(Error {
        message: message,
        loc: self.loc(),
    }))
}

fn Lexer::lex_char_literal(&self): Result<Token, &Error> {
    let loc = self.loc()

    // skip start quote
    self.next_char()

    let char = self.current_char()? as u8
    if char == '\\' {
        // skip `\`
        self.next_char()

        let c = self.current_char()? as u8
        let correct_escape = c == 'n' || c == 'r' || c == 't' \
            || c == '0' || c == '\\' || c == '\''

        if !correct_escape {
            let message = String::from_str_in(
                self.error_arena,
                "ParseError: Invalid escape sequence: \\",
            )
            message.push(c)

            return Err(self.error_arena.new!(Error {
                message: message,
                loc: self.loc(),
            }))
        }

        // skip escaped character
        self.next_char()
    } else {
        // skip actual character
        self.next_char()
    }

    let end_quote = self.current_char()? as u8
    if end_quote != '\'' {
        let message = String::from_str_in(
            self.error_arena,
            "ParseError: Unexpected character `",
        )
        message.push(end_quote)
        message.push_str("`, expected `'`")

        return Err(self.error_arena.new!(Error {
            message: message,
            loc: self.loc(),
        }))
    }

    // skip end quote
    self.next_char()

    loc.end_pos = self.source_pos

    return Ok(Token {
        type_: TokenType::CharLiteral(),
        loc: loc,
    })
}

fn Lexer::lex_string_literal(&self): Result<Token, &Error> {
    let loc = self.loc()

    // skip start quote
    self.next_char()

    loop {
        let char = self.current_char()? as u8
        if char == '"' {
            break
        }

        if char == '\\' {
            self.next_char()

            let c = self.current_char()? as u8
            let correct_escape = c == 'n' || c == 'r' || c == 't' \
                || c == '0' || c == '\\' || c == '"'

            if !correct_escape {
                let message = String::from_str_in(
                    self.error_arena,
                    "ParseError: Invalid escape sequence: \\",
                )
                message.push(c)

                return Err(self.error_arena.new!(Error {
                    message: message,
                    loc: self.loc(),
                }))
            }
        }

        self.next_char()
    }

    // skip end quote
    self.next_char()

    loc.end_pos = self.source_pos

    return Ok(Token {
        type_: TokenType::StringLiteral(),
        loc: loc,
    })
}

fn Lexer::lex_int_literal(&self): Result<Token, &Error> {
    let loc = self.loc()

    let hex = false
    if self.current_char()? as u8 == '0' {
        self.next_char()

        if self.current_char()? as u8 == 'x' {
            self.next_char()
            hex = true
        }
    }

    loop {
        let c = self.current_char()? as u8

        let int_char = c == '_' \
            || (c >= '0' && c <= '9') \
            || (hex && c >= 'A' && c <= 'F')

        if !int_char {
            break
        }

        self.next_char()
    }

    loc.end_pos = self.source_pos

    return Ok(Token {
        type_: TokenType::IntLiteral(),
        loc: loc,
    })
}

fn Lexer::parse_int_literal_value(int_literal: str): i64 {
    let radix = 10 as i64
    if int_literal.starts_with("0x") {
        int_literal = int_literal.skip_chars(2)
        radix = 16 as i64
    }

    let value = 0 as i64
    for i in 0..int_literal.size {
        let digit = int_literal.char_at(i)
        if digit == '_' {
            continue
        }

        if digit >= '0' && digit <= '9' {
            value = value * radix + (digit - '0') as i64
        } else {
            value = value * radix + 10 as i64 + (digit - 'A') as i64
        }
    }
    return value
}

fn Lexer::lex_symbol(&self): Result<Token, &Error> {
    let loc = self.loc()

    while Lexer::is_symbol_char(self.current_char()? as u8) {
        self.next_char()
    }

    loc.end_pos = self.source_pos

    return Ok(Token {
        type_: TokenType::Symbol(),
        loc: loc,
    })
}

fn Lexer::lex_delim(&self): Result<Token, &Error> {
    let loc = self.loc()

    self.next_char()

    loc.end_pos = self.source_pos

    return Ok(Token {
        type_: TokenType::Delim(),
        loc: loc,
    })
}

fn Lexer::lex_operator(&self): Result<Token, &Error> {
    let loc = self.loc()

    loop {
        let current_op = self.source.slice(loc.pos.offset, self.source_pos.offset + 1)

        let is_start_of_operator = false
        for i in 0..@const_slice_len(OPERATORS) {
            let operator = *array_at!<str>(OPERATORS, i)

            if operator.starts_with(current_op) {
                is_start_of_operator = true
                break
            }
        }

        if !is_start_of_operator {
            break
        }

        self.next_char()

        // EOF check
        let _ = self.current_char()?
    }

    let op = self.source.slice(loc.pos.offset, self.source_pos.offset)

    let matched_fully = false
    for i in 0..@const_slice_len(OPERATORS) {
        let operator = *array_at!<str>(OPERATORS, i)

        if operator.equals(op) {
            matched_fully = true
            break
        }
    }

    if !matched_fully {
        let message = String::from_str_in(
            self.error_arena,
            "ParseError: Unexpected char: '",
        )
        message.push(self.current_char()? as u8)
        message.push_str("'")

        return Err(self.error_arena.new!(Error {
            message: message,
            loc: self.loc(),
        }))
    }

    loc.end_pos = self.source_pos

    return Ok(Token {
        type_: TokenType::Operator(),
        loc: loc,
    })
}

fn Lexer::skip_space(&self) {
    loop {
        let c = self.current_char() catch _ {
            break
        }

        if !Lexer::is_space_char(c as u8) {
            break
        }

        self.next_char()
    }

    let char = self.current_char() catch _ {
        return
    }

    if char as u8 == '\\' {
        let loc = self.loc()

        self.next_char()

        let next_char = self.current_char() catch _ {
            self.backslashes.push!(loc)
            return
        }

        if next_char as u8 == '\\' {
            self.next_char()
            loc.end_pos = self.source_pos
            self.double_backslashes.push!(loc)
        } else {
            self.backslashes.push!(loc)
        }

        self.skip_space()

        return
    }

    if char as u8 == '/' {
        let next_char = self.peek_next_char() catch _ {
            return
        }

        if next_char as u8 != '/' {
            return
        }

        let loc = self.loc()

        self.next_char()
        self.next_char()

        loop {
            let comment_char = self.current_char() catch _ {
                break
            }

            if comment_char as u8 == '\n' {
                break
            }

            self.next_char()
        }

        loc.end_pos = self.source_pos
        self.comments.push!(loc)

        self.skip_space()
    }
}

fn Lexer::is_space_char(c: u8): bool {
    return c == ' ' || c == '\t' || c == '\n' || c == '\r'
}

fn Lexer::is_symbol_char(c: u8): bool {
    return c >= 'a' && c <= 'z' \
        || c >= 'A' && c <= 'Z' \
        || c >= '0' && c <= '9' \
        || c == '_'
}

fn Lexer::is_delim_char(c: u8): bool {
    return c == '(' || c == ')' \
        || c == '{' || c == '}' \
        || c == '[' || c == ']' \
        || c == ',' || c == '\\'
}

const OPERATORS = [str][
    "=", \\ "==", \\ "!=",
    "&&", \\ "||", \\ "!",
    "<", \\ "<=",
    ">", \\ ">=",
    "+", \\ "+=",
    "-", \\ "-=",
    "*", \\ "*=",
    "/", \\ "/=",
    "%", \\ "%=",
    "&", \\ "&=",
    "<<", \\ "<<=",
    ">>", \\ ">>=",
    "^", \\ "^=",
    "|", \\ "|=",

    "*&", \\ "|>", \\ ".", \\ "..",
    ":", \\ "::", \\ "@", \\ "?",
]

fn Lexer::is_operator_start_char(c: u8): bool {
    for i in 0..@const_slice_len(OPERATORS) {
        let operator = *array_at!<str>(OPERATORS, i)

        if operator.char_at(0) == c {
            return true
        }
    }

    return false
}

fn Lexer::next_char(&self) {
    let char = self.current_char catch _ {
        return
    }

    self.source_pos.offset += char_len_utf8(char)

    if char as u8 == '\n' {
        self.source_pos.line += 1
        self.source_pos.col = 1
    } else {
        self.source_pos.col += 1
    }

    self.current_char = read_utf8_codepoint(self.source, self.source_pos.offset)
}

fn Lexer::current_char(&self): Result<u32, &Error> {
    return self.map_utf8_read_err(self.current_char)
}

fn Lexer::peek_next_char(&self): Result<u32, &Error> {
    let char = self.current_char catch _ {
        return self.current_char()
    }

    return self.map_utf8_read_err(read_utf8_codepoint(
        self.source,
        self.source_pos.offset + char_len_utf8(char),
    ))
}

fn Lexer::map_utf8_read_err(&self, utf8_read: Result<u32, UTF8ReadError>): Result<u32, &Error> {
    let char = utf8_read catch err {
        let message = "ParseError: Invalid UTF-8 sequence"
        if err == UTF8ReadError::EndOfSource() {
            message = "ParseError: Unexpected EOF"
        }
        return Err(self.error_arena.new!(Error {
            message: String::from_str_in(self.error_arena, message),
            loc: self.loc(),
        }))
    }

    return Ok(char)
}

fn Lexer::loc(&self): Loc {
    let pos = self.source_pos

    let end_pos = pos
    end_pos.col += 1

    return Loc {
        file_index: self.file_index,
        pos: pos,
        end_pos: end_pos,
    }
}

enum UTF8ReadError {
    EndOfSource,
    InvalidUtf8,
}

fn read_utf8_codepoint(source: str, offset: u32): Result<u32, UTF8ReadError> {
    if offset >= source.size {
        return Err(UTF8ReadError::EndOfSource())
    }

    let first = source.char_at(offset) as u32
    let width = 0
    let min = 0
    let code = 0

    // determine sequence length and minimum valid code point
    if first <= 0x7F {
        width = 1
        min = 0
        code = first as u32
    } else if first >= 0xC2 && first <= 0xDF {
        width = 2
        min = 0x80
        code = (first & 0x1F) as u32
    } else if first >= 0xE0 && first <= 0xEF {
        width = 3
        min = 0x800
        code = (first & 0x0F) as u32
    } else if first >= 0xF0 && first <= 0xF4 {
        width = 4
        min = 0x10000
        code = (first & 0x07) as u32
    } else {
        return Err(UTF8ReadError::InvalidUtf8())
    }

    if offset + width > source.size {
        return Err(UTF8ReadError::EndOfSource())
    }

    // process continuation bytes
    for i in 1..width {
        let b = source.char_at(offset + i) as u32
        if (b & 0xC0) != 0x80 {
            return Err(UTF8ReadError::InvalidUtf8())
        }
        code = (code << 6) | ((b & 0x3F) as u32)
    }

    // validate code point
    if code < min || code > 0x10FFFF || (code >= 0xD800 && code <= 0xDFFF) {
        return Err(UTF8ReadError::InvalidUtf8())
    }

    return Ok(code)
}

fn char_len_utf8(char: u32): u32 {
    if char <= 0x80 {
        return 1
    } else if char <= 0x800 {
        return 2
    } else if char <= 0x10000 {
        return 3
    } else {
        return 4
    }
}
