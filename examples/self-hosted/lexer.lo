include "./core.lo"

struct Token {
    loc: Loc,
    type_: TokenType,
}

enum TokenType {
    StringLiteral,
    CharLiteral,
    IntLiteral,
    Symbol,
    Delim,
    Operator,
    Terminal,
}

fn TokenType::to_str(self): str {
    if self == TokenType::StringLiteral() {
        return "StringLiteral"
    } else if self == TokenType::CharLiteral() {
        return "CharLiteral"
    } else if self == TokenType::IntLiteral() {
        return "IntLiteral"
    } else if self == TokenType::Symbol() {
        return "Symbol"
    } else if self == TokenType::Delim() {
        return "Delim"
    } else if self == TokenType::Operator() {
        return "Operator"
    } else if self == TokenType::Terminal() {
        return "Terminal"
    }

    // TODO: fix `else { @unreachable()}` not working
    @unreachable()
}

struct Lexer {
    // context
    source: str,
    file_index: u32,
    error_arena: &Arena,

    // output
    tokens: &Vec of Token,
}

fn Lexer::new(source: str, file_index: u32, error_arena: &Arena): &Lexer {
    return heap::new!(Lexer {
        source: source,
        file_index: file_index,
        error_arena: error_arena,
        tokens: Vec::new!<Token>(),
    })
}

fn Lexer::free(&self) {
    self.tokens.free()
}

// TODO: implement proper
fn Lexer::lex_file(&self): Result<void, &Error> {
    let loc = Loc::internal()
    loc.file_index = self.file_index

    loc.pos = Pos { offset: 0, line: 1, col: 1 }
    loc.end_pos = Pos { offset: 7, line: 1, col: 8 }
    self.tokens.push!(Token { loc: loc, type_: TokenType::Symbol() })

    return Ok()
}
