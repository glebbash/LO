include "./core.lo"

struct Token {
    type_: TokenType,
    loc: Loc,
}

enum TokenType {
    StringLiteral,
    CharLiteral,
    IntLiteral,
    Symbol,
    Delim,
    Operator,
    Terminal,
}

fn TokenType::to_str(self): str {
    if self == TokenType::StringLiteral {
        return "StringLiteral"
    } else if self == TokenType::CharLiteral {
        return "CharLiteral"
    } else if self == TokenType::IntLiteral {
        return "IntLiteral"
    } else if self == TokenType::Symbol {
        return "Symbol"
    } else if self == TokenType::Delim {
        return "Delim"
    } else if self == TokenType::Operator {
        return "Operator"
    } else if self == TokenType::Terminal {
        return "Terminal"
    } else {
        @unreachable()
    }
}

fn Token::get_value(&self, source: str): str {
    if self.is_terminal() {
        return "<EOF>"
    }

    return self.loc.read_span(source)
}

fn Token::is(&self, type_: TokenType, value: str, source: str): bool {
    return self.is_any(type_) && self.get_value(source).equals(value)
}

fn Token::is_any(&self, type_: TokenType): bool {
    return self.type_ == type_
}

fn Token::is_terminal(&self): bool {
    return self.is_any(TokenType::Terminal)
}

struct Lexer {
    // context
    source: str,
    file_index: u32,
    error_arena: &Arena,

    // state
    source_pos: Pos,
    current_char: Result(u32, UTF8ReadError),
    was_newline: bool,

    // output
    tokens: &Vec(Token),
    comments: &Vec(Loc),
    backslashes: &Vec(Loc),
    double_backslashes: &Vec(Loc),
}

fn Lexer::new(error_arena: &Arena, source: str, file_index: u32): &Lexer {
    return heap::new!(Lexer {
        source: source,
        file_index: file_index,
        error_arena: error_arena,

        source_pos: Pos { offset: 0, line: 1, col: 1 },
        current_char: read_utf8_codepoint(source, 0),
        was_newline: false,

        tokens: Vec::new!<Token>(),
        comments: Vec::new!<Loc>(),
        backslashes: Vec::new!<Loc>(),
        double_backslashes: Vec::new!<Loc>(),
    })
}

fn Lexer::free(&self) {
    self.tokens.free()
    self.comments.free()
    self.backslashes.free()
    self.double_backslashes.free()
    heap::free(self)
}

fn Lexer::lex_file(&self): Result(void, &Error) {
    self.skip_space()

    while self.source_pos.offset < self.source.size {
        let token = self.lex_token()?
        self.tokens.push!(token)

        self.skip_space()
    }

    self.tokens.push!(Token {
        type_: TokenType::Terminal,
        loc: self.loc(),
    })

    return Ok()
}

fn Lexer::lex_token(&self): Result(Token, &Error) {
    let char = self.current_char()? as u8

    if char == '\'' {
        return self.lex_char_literal()
    }

    if char == '"' {
        return self.lex_string_literal()
    }

    if char >= '0' && char <= '9' {
        return self.lex_int_literal()
    }

    // NOTE: must be after int check because it matches digits
    if Lexer::is_symbol_char(char) {
        return self.lex_symbol()
    }

    if Lexer::is_delim_char(char) {
        return self.lex_delim()
    }

    if Lexer::is_operator_start_char(char) {
        return self.lex_operator()
    }

    let message = String::from_str_in(self.error_arena, "Unexpected char: ")
    message.push(char)

    return Err(self.error_arena.new!(Error {
        message: message,
        loc: self.loc(),
    }))
}

fn Lexer::lex_char_literal(&self): Result(Token, &Error) {
    let loc = self.loc()

    // skip start quote
    self.next_char()

    let char = self.current_char()? as u8
    if char == '\\' {
        // skip `\`
        self.next_char()

        let c = self.current_char()? as u8
        let correct_escape = c == 'n' || c == 'r' || c == 't' \
            || c == '0' || c == '\\' || c == '\''

        if !correct_escape {
            let message = String::from_str_in(
                self.error_arena,
                "ParseError: Invalid escape sequence: \\",
            )
            message.push(c)

            return Err(self.error_arena.new!(Error {
                message: message,
                loc: self.loc(),
            }))
        }

        // skip escaped character
        self.next_char()
    } else {
        // skip actual character
        self.next_char()
    }

    let end_quote = self.current_char()? as u8
    if end_quote != '\'' {
        let message = String::from_str_in(
            self.error_arena,
            "ParseError: Unexpected character `",
        )
        message.push(end_quote)
        message.push_str("`, expected `'`")

        return Err(self.error_arena.new!(Error {
            message: message,
            loc: self.loc(),
        }))
    }

    // skip end quote
    self.next_char()

    loc.end_pos = self.source_pos

    return Ok(Token {
        type_: TokenType::CharLiteral,
        loc: loc,
    })
}

fn Lexer::lex_string_literal(&self): Result(Token, &Error) {
    let loc = self.loc()

    // skip start quote
    self.next_char()

    loop {
        let char = self.current_char()? as u8
        if char == '"' {
            break
        }

        if char == '\\' {
            self.next_char()

            let c = self.current_char()? as u8
            let correct_escape = c == 'n' || c == 'r' || c == 't' \
                || c == '0' || c == '\\' || c == '"'

            if !correct_escape {
                let message = String::from_str_in(
                    self.error_arena,
                    "ParseError: Invalid escape sequence: \\",
                )
                message.push(c)

                return Err(self.error_arena.new!(Error {
                    message: message,
                    loc: self.loc(),
                }))
            }
        }

        self.next_char()
    }

    // skip end quote
    self.next_char()

    loc.end_pos = self.source_pos

    return Ok(Token {
        type_: TokenType::StringLiteral,
        loc: loc,
    })
}

fn Lexer::lex_int_literal(&self): Result(Token, &Error) {
    let loc = self.loc()

    let hex = false
    if self.current_char()? as u8 == '0' {
        self.next_char()

        if self.current_char()? as u8 == 'x' {
            self.next_char()
            hex = true
        }
    }

    loop {
        let c = self.current_char()? as u8

        let int_char = c == '_' \
            || (c >= '0' && c <= '9') \
            || (hex && c >= 'A' && c <= 'F')

        if !int_char {
            break
        }

        self.next_char()
    }

    loc.end_pos = self.source_pos

    return Ok(Token {
        type_: TokenType::IntLiteral,
        loc: loc,
    })
}

fn Lexer::parse_int_literal_value(int_literal: str): i64 {
    let radix = 10 as i64
    if int_literal.starts_with("0x") {
        int_literal = int_literal.skip_chars(2)
        radix = 16 as i64
    }

    let value = 0 as i64
    for i in 0..int_literal.size {
        let digit = int_literal.char_at(i)
        if digit == '_' {
            continue
        }

        if digit >= '0' && digit <= '9' {
            value = value * radix + (digit - '0') as i64
        } else {
            value = value * radix + 10 as i64 + (digit - 'A') as i64
        }
    }
    return value
}

fn Lexer::lex_symbol(&self): Result(Token, &Error) {
    let loc = self.loc()

    while Lexer::is_symbol_char(self.current_char()? as u8) {
        self.next_char()
    }

    loc.end_pos = self.source_pos

    return Ok(Token {
        type_: TokenType::Symbol,
        loc: loc,
    })
}

fn Lexer::lex_delim(&self): Result(Token, &Error) {
    let loc = self.loc()

    self.next_char()

    loc.end_pos = self.source_pos

    return Ok(Token {
        type_: TokenType::Delim,
        loc: loc,
    })
}

fn Lexer::lex_operator(&self): Result(Token, &Error) {
    let loc = self.loc()

    loop {
        let current_op = self.source.slice(loc.pos.offset, self.source_pos.offset + 1)

        let is_start_of_operator = false
        for i in 0..@const_slice_len(OPERATORS) {
            let operator = *array_at!<str>(OPERATORS, i)

            if operator.starts_with(current_op) {
                is_start_of_operator = true
                break
            }
        }

        if !is_start_of_operator {
            break
        }

        self.next_char()

        // EOF check
        let _ = self.current_char()?
    }

    let op = self.source.slice(loc.pos.offset, self.source_pos.offset)

    let matched_fully = false
    for i in 0..@const_slice_len(OPERATORS) {
        let operator = *array_at!<str>(OPERATORS, i)

        if operator.equals(op) {
            matched_fully = true
            break
        }
    }

    if !matched_fully {
        let message = String::from_str_in(
            self.error_arena,
            "ParseError: Unexpected char: '",
        )
        message.push(self.current_char()? as u8)
        message.push_str("'")

        return Err(self.error_arena.new!(Error {
            message: message,
            loc: self.loc(),
        }))
    }

    loc.end_pos = self.source_pos

    return Ok(Token {
        type_: TokenType::Operator,
        loc: loc,
    })
}

fn Lexer::skip_space(&self) {
    loop {
        let c = self.current_char() catch _ {
            break
        }

        if !Lexer::is_space_char(c as u8) {
            break
        }

        self.next_char()
    }

    let char = self.current_char() catch _ {
        return
    }

    if char as u8 == '\\' {
        let loc = self.loc()

        self.next_char()

        let next_char = self.current_char() catch _ {
            self.backslashes.push!(loc)
            return
        }

        if next_char as u8 == '\\' {
            self.next_char()
            loc.end_pos = self.source_pos
            self.double_backslashes.push!(loc)
        } else {
            self.backslashes.push!(loc)
        }

        self.skip_space()

        return
    }

    if char as u8 == '/' {
        let next_char = self.peek_next_char() catch _ {
            return
        }

        if next_char as u8 != '/' {
            return
        }

        let loc = self.loc()

        self.next_char()
        self.next_char()

        loop {
            let comment_char = self.current_char() catch _ {
                break
            }

            if comment_char as u8 == '\n' {
                break
            }

            self.next_char()
        }

        loc.end_pos = self.source_pos
        self.comments.push!(loc)

        self.skip_space()
    }
}

fn Lexer::is_space_char(c: u8): bool {
    return c == ' ' || c == '\t' || c == '\n' || c == '\r'
}

fn Lexer::is_symbol_char(c: u8): bool {
    return c >= 'a' && c <= 'z' \
        || c >= 'A' && c <= 'Z' \
        || c >= '0' && c <= '9' \
        || c == '_'
}

fn Lexer::is_delim_char(c: u8): bool {
    return c == '(' || c == ')' \
        || c == '{' || c == '}' \
        || c == '[' || c == ']' \
        || c == ',' || c == '\\'
}

fn Lexer::next_char(&self) {
    let char = self.current_char catch _ {
        return
    }

    self.source_pos.offset += char_len_utf8(char)

    if char as u8 == '\n' {
        self.source_pos.line += 1
        self.source_pos.col = 1
    } else {
        self.source_pos.col += 1
    }

    self.current_char = read_utf8_codepoint(self.source, self.source_pos.offset)
}

fn Lexer::current_char(&self): Result(u32, &Error) {
    return self.map_utf8_read_err(self.current_char)
}

fn Lexer::peek_next_char(&self): Result(u32, &Error) {
    let char = self.current_char catch _ {
        return self.current_char()
    }

    return self.map_utf8_read_err(read_utf8_codepoint(
        self.source,
        self.source_pos.offset + char_len_utf8(char),
    ))
}

fn Lexer::map_utf8_read_err(&self, utf8_read: Result(u32, UTF8ReadError)): Result(u32, &Error) {
    let char = utf8_read catch err {
        let message = "ParseError: Invalid UTF-8 sequence"
        if err == UTF8ReadError::EndOfSource {
            message = "ParseError: Unexpected EOF"
        }
        return Err(self.error_arena.new!(Error {
            message: String::from_str_in(self.error_arena, message),
            loc: self.loc(),
        }))
    }

    return Ok(char)
}

fn Lexer::loc(&self): Loc {
    let pos = self.source_pos

    let end_pos = pos
    end_pos.col += 1

    return Loc {
        file_index: self.file_index,
        pos: pos,
        end_pos: end_pos,
    }
}

struct QuotedString {
    loc: Loc,
}

fn QuotedString::new(loc: Loc): QuotedString {
    return QuotedString { loc: loc }
}

fn QuotedString::get_repr(self, source: str): str {
    return self.loc.read_span(source)
}

fn QuotedString::get_value(self, source: str): String {
    let repr = self.get_repr(source)
    let value = String::new(16)

    // skip start quote
    let i = 1
    loop {
        let char = repr.char_at(i)
        i += 1

        if char == '"' {
            break
        } else if char == '\\' {
            let next_char = repr.char_at(i)
            i += 1

            if next_char == 'n' {
                value.push('\n')
            } else if next_char == 'r' {
                value.push('\r')
            } else if next_char == 't' {
                value.push('\t')
            } else if next_char == '0' {
                value.push('\0')
            } else if next_char == '\\' {
                value.push('\\')
            } else if next_char == '"' {
                value.push('"')
            }
            @unreachable()
        } else {
            value.push(char)
        }
    }

    return value
}

const OPERATORS = [str][
    "=", \\ "==", \\ "!=",
    "&&", \\ "||", \\ "!",
    "<", \\ "<=",
    ">", \\ ">=",
    "+", \\ "+=",
    "-", \\ "-=",
    "*", \\ "*=",
    "/", \\ "/=",
    "%", \\ "%=",
    "&", \\ "&=",
    "<<", \\ "<<=",
    ">>", \\ ">>=",
    "^", \\ "^=",
    "|", \\ "|=",

    "*&", \\ "|>", \\ ".", \\ "..",
    ":", \\ "::", \\ "@", \\ "?",
]

fn Lexer::is_operator_start_char(c: u8): bool {
    for i in 0..@const_slice_len(OPERATORS) {
        let operator = *array_at!<str>(OPERATORS, i)

        if operator.char_at(0) == c {
            return true
        }
    }

    return false
}

enum InfixOpTag {
    Equal,
    NotEqual,
    Less,
    Greater,
    LessEqual,
    GreaterEqual,

    Add,
    Sub,
    Mul,
    Div,
    Mod,
    And,
    BitAnd,
    Or,
    BitOr,
    ShiftLeft,
    ShiftRight,

    Assign,
    AddAssign,
    SubAssign,
    MulAssign,
    DivAssign,
    ModAssign,
    BitAndAssign,
    BitOrAssign,
    ShiftLeftAssign,
    ShiftRightAssign,

    Cast,
    FieldAccess,
    Catch,

    ErrorPropagation,

    ExprPipe,
}

struct InfixOp {
    tag: InfixOpTag,
    bp: u32,
    bp_next: u32,
}

fn InfixOp::parse(repr: str): Result(InfixOp, &void) {
    if repr.equals("catch") {
        return Ok(InfixOp::left_assoc(InfixOpTag::Catch, 14))
    }
    if repr.equals(".") {
        return Ok(InfixOp::left_assoc(InfixOpTag::FieldAccess, 13))
    }
    if repr.equals("?") {
        return Ok(InfixOp::left_assoc(InfixOpTag::ErrorPropagation, 12))
    }
    if repr.equals("as") {
        return Ok(InfixOp::left_assoc(InfixOpTag::Cast, 11))
    }
    if repr.equals("%") {
        return Ok(InfixOp::left_assoc(InfixOpTag::Mod, 10))
    }
    if repr.equals("/") {
        return Ok(InfixOp::left_assoc(InfixOpTag::Div, 10))
    }
    if repr.equals("*") {
        return Ok(InfixOp::left_assoc(InfixOpTag::Mul, 10))
    }
    if repr.equals("-") {
        return Ok(InfixOp::left_assoc(InfixOpTag::Sub, 9))
    }
    if repr.equals("+") {
        return Ok(InfixOp::left_assoc(InfixOpTag::Add, 9))
    }
    if repr.equals(">>") {
        return Ok(InfixOp::left_assoc(InfixOpTag::ShiftRight, 8))
    }
    if repr.equals("<<") {
        return Ok(InfixOp::left_assoc(InfixOpTag::ShiftLeft, 8))
    }
    if repr.equals("&") {
        return Ok(InfixOp::left_assoc(InfixOpTag::BitAnd, 7))
    }
    if repr.equals("|") {
        return Ok(InfixOp::left_assoc(InfixOpTag::BitOr, 6))
    }
    if repr.equals(">=") {
        return Ok(InfixOp::left_assoc(InfixOpTag::GreaterEqual, 5))
    }
    if repr.equals(">") {
        return Ok(InfixOp::left_assoc(InfixOpTag::Greater, 5))
    }
    if repr.equals("<=") {
        return Ok(InfixOp::left_assoc(InfixOpTag::LessEqual, 5))
    }
    if repr.equals("<") {
        return Ok(InfixOp::left_assoc(InfixOpTag::Less, 5))
    }
    if repr.equals("!=") {
        return Ok(InfixOp::none_assoc(InfixOpTag::NotEqual, 5))
    }
    if repr.equals("==") {
        return Ok(InfixOp::none_assoc(InfixOpTag::Equal, 5))
    }
    if repr.equals("&&") {
        return Ok(InfixOp::left_assoc(InfixOpTag::And, 4))
    }
    if repr.equals("||") {
        return Ok(InfixOp::left_assoc(InfixOpTag::Or, 3))
    }
    if repr.equals("|>") {
        return Ok(InfixOp::left_assoc(InfixOpTag::ExprPipe, 2))
    }
    if repr.equals("=") {
        return Ok(InfixOp::none_assoc(InfixOpTag::Assign, 1))
    }
    if repr.equals("+=") {
        return Ok(InfixOp::none_assoc(InfixOpTag::AddAssign, 1))
    }
    if repr.equals("-=") {
        return Ok(InfixOp::none_assoc(InfixOpTag::SubAssign, 1))
    }
    if repr.equals("*=") {
        return Ok(InfixOp::none_assoc(InfixOpTag::MulAssign, 1))
    }
    if repr.equals("/=") {
        return Ok(InfixOp::none_assoc(InfixOpTag::DivAssign, 1))
    }
    if repr.equals("%=") {
        return Ok(InfixOp::none_assoc(InfixOpTag::ModAssign, 1))
    }
    if repr.equals("&=") {
        return Ok(InfixOp::none_assoc(InfixOpTag::BitAndAssign, 1))
    }
    if repr.equals("|=") {
        return Ok(InfixOp::none_assoc(InfixOpTag::BitOrAssign, 1))
    }
    if repr.equals("<<=") {
        return Ok(InfixOp::none_assoc(InfixOpTag::ShiftLeftAssign, 1))
    }
    if repr.equals(">>=") {
        return Ok(InfixOp::none_assoc(InfixOpTag::ShiftRightAssign, 1))
    }
    return Err(1 as &void)
}

fn InfixOp::left_assoc(tag: InfixOpTag, bp: u32): InfixOp {
    return InfixOp { tag: tag, bp: bp, bp_next: bp + 1 }
}

fn InfixOp::none_assoc(tag: InfixOpTag, bp: u32): InfixOp {
    return InfixOp { tag: tag, bp: bp, bp_next: bp }
}

enum PrefixOpTag {
    Not,
    Reference,
    Dereference,
    Positive,
    Negative,
}

struct PrefixOp {
    tag: PrefixOpTag,
    bp_next: u32,
}

fn PrefixOp::parse(repr: str): Result(PrefixOp, &void) {
    if repr.equals("!") {
        return Ok(PrefixOp::left_assoc(PrefixOpTag::Not, 8))
    }
    if repr.equals("&") {
        return Ok(PrefixOp::left_assoc(PrefixOpTag::Reference, 8))
    }
    if repr.equals("*") {
        return Ok(PrefixOp::left_assoc(PrefixOpTag::Dereference, 8))
    }
    if repr.equals("+") {
        return Ok(PrefixOp::left_assoc(PrefixOpTag::Positive, 9))
    }
    if repr.equals("-") {
        return Ok(PrefixOp::left_assoc(PrefixOpTag::Negative, 9))
    }
    return Err(1 as &void)
}

fn PrefixOp::left_assoc(tag: PrefixOpTag, bp: u32): PrefixOp {
    return PrefixOp { tag: tag, bp_next: bp + 1 }
}

enum UTF8ReadError {
    EndOfSource,
    InvalidUtf8,
}

fn read_utf8_codepoint(source: str, offset: u32): Result(u32, UTF8ReadError) {
    if offset >= source.size {
        return Err(UTF8ReadError::EndOfSource)
    }

    let first = source.char_at(offset) as u32
    let width = 0
    let min = 0
    let code = 0

    // determine sequence length and minimum valid code point
    if first <= 0x7F {
        width = 1
        min = 0
        code = first as u32
    } else if first >= 0xC2 && first <= 0xDF {
        width = 2
        min = 0x80
        code = (first & 0x1F) as u32
    } else if first >= 0xE0 && first <= 0xEF {
        width = 3
        min = 0x800
        code = (first & 0x0F) as u32
    } else if first >= 0xF0 && first <= 0xF4 {
        width = 4
        min = 0x10000
        code = (first & 0x07) as u32
    } else {
        return Err(UTF8ReadError::InvalidUtf8)
    }

    if offset + width > source.size {
        return Err(UTF8ReadError::EndOfSource)
    }

    // process continuation bytes
    for i in 1..width {
        let b = source.char_at(offset + i) as u32
        if (b & 0xC0) != 0x80 {
            return Err(UTF8ReadError::InvalidUtf8)
        }
        code = (code << 6) | ((b & 0x3F) as u32)
    }

    // validate code point
    if code < min || code > 0x10FFFF || (code >= 0xD800 && code <= 0xDFFF) {
        return Err(UTF8ReadError::InvalidUtf8)
    }

    return Ok(code)
}

fn char_len_utf8(char: u32): u32 {
    if char <= 0x80 {
        return 1
    } else if char <= 0x800 {
        return 2
    } else if char <= 0x10000 {
        return 3
    } else {
        return 4
    }
}
