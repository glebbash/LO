include "./core.lo"
include "./lexer.lo"
include "./ast.lo"

struct ParsingContext {
    struct_literal_allowed: bool,
}

struct Parser {
    // context
    error_arena: &Arena,
    lexer: &Lexer,
    source: str,

    // state
    tokens_processed: u32,
    context_stack: &Vec(ParsingContext),

    // output
    ast_arena: &Arena,
    ast: &Vec(TopLevelExpr),
}

fn Parser::new(lexer: &Lexer): &Parser {
    let context_stack = Vec::new!<ParsingContext>()
    context_stack.push!(ParsingContext {
        struct_literal_allowed: true,
    })

    return heap::new!(Parser {
        error_arena: lexer.error_arena,
        lexer: lexer,
        source: lexer.source,
        tokens_processed: 0,
        context_stack: context_stack,

        ast_arena: Arena::new(512),
        ast: Vec::new!<TopLevelExpr>(),
    })
}

fn Parser::free(&self) {
    self.lexer.free()
    self.context_stack.free()
    self.ast_arena.free()
    self.ast.free()
    heap::free(self)
}

fn Parser::parse_file(&self): Result(void, &Error) {
    while !self.current().is_terminal() {
        let expr = self.parse_top_level_expr()?
        self.ast.push!(expr)
    }

    return Ok()
}

fn Parser::parse_top_level_expr(&self): Result(TopLevelExpr, &Error) {
    if self.eat(TokenType::Symbol, "export") != null {
        let loc = self.prev().loc

        if self.eat(TokenType::Symbol, "fn") != null {
            let fn_def = self.parse_fn_def(true, loc)?
            return Ok(TopLevelExpr::FnDef(fn_def))
        }

        if self.eat(TokenType::Symbol, "memory") != null {
            let memory_def = self.parse_memory_def(true, loc)?
            return Ok(TopLevelExpr::MemoryDef(self.ast_arena.new!(memory_def)))
        }

        let unexpected = self.current()
        let message = String::from_str("Unexpected exportable: ")
        message.push_str(unexpected.get_value(self.lexer.source))

        return Err(self.error_arena.new!(Error {
            message: message,
            loc: unexpected.loc,
        }))
    }

    if self.eat(TokenType::Symbol, "fn") != null {
        let fn_def = self.parse_fn_def(false, self.prev().loc)?
        return Ok(TopLevelExpr::FnDef(fn_def))
    }

    if self.eat(TokenType::Symbol, "memory") != null {
        let memory_def = self.parse_memory_def(false, self.prev().loc)?
        return Ok(TopLevelExpr::MemoryDef(self.ast_arena.new!(memory_def)))
    }

    if self.eat(TokenType::Symbol, "include") != null {
        let loc = self.prev().loc

        let file_path = self.expect_any(TokenType::StringLiteral)?
        let alias = null as &IdentExpr
        if self.eat(TokenType::Symbol, "as") != null {
            alias = self.ast_arena.new!(self.parse_ident()?)
        }

        let with_extern = false
        if self.eat(TokenType::Symbol, "with") != null {
            let _ = self.expect(TokenType::Symbol, "extern")?
            with_extern = true
        }

        loc.end_pos = self.prev().loc.end_pos

        return Ok(TopLevelExpr::Include(self.ast_arena.new!(IncludeExpr {
            file_path: QuotedString::new(file_path.loc),
            alias: alias,
            with_extern: with_extern,
            loc: loc,
        })))
    }

    if self.eat(TokenType::Symbol, "import") != null {
        let loc = self.prev().loc

        let _ = self.expect(TokenType::Symbol, "from")?
        let module_name = self.expect_any(TokenType::StringLiteral)?

        let _ = self.expect(TokenType::Delim, "{")?

        let items = Vec::new!<ImportItem>()
        while self.eat(TokenType::Delim, "}") == null {
            let item = self.parse_importable()?
            items.push!(item)
        }

        loc.end_pos = self.prev().loc.end_pos

        return Ok(TopLevelExpr::Import(self.ast_arena.new!(ImportExpr {
            module_name: QuotedString::new(module_name.loc),
            items: items,
            loc: loc,
        })))
    }

    if self.eat(TokenType::Symbol, "const") != null {
        let loc = self.prev().loc

        let const_name = self.parse_ident()?
        let _ = self.expect(TokenType::Operator, "=")?
        let const_value = self.parse_code_expr(0)?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(TopLevelExpr::ConstDef(self.ast_arena.new!(ConstDefExpr {
            const_name: const_name,
            const_value: const_value,
            loc: loc,
        })))
    }

    if self.eat(TokenType::Symbol, "struct") != null {
        let loc = self.prev().loc

        let struct_name = self.parse_ident()?

        let fields = Vec::new!<StructDefField>()

        let _ = self.expect(TokenType::Delim, "{")?
        while self.eat(TokenType::Delim, "}") == null {
            let field_loc = self.current().loc

            let field_name = self.parse_ident()?
            let _ = self.expect(TokenType::Operator, ":")?
            let field_type = self.parse_type_expr()?

            field_loc.end_pos = self.prev().loc.end_pos

            fields.push!(StructDefField {
                field_name: field_name,
                field_type: field_type,
                loc: field_loc,
            })

            if !self.current().is(TokenType::Delim, "}", self.source) {
                let _ = self.expect(TokenType::Delim, ",")?
            }
        }

        loc.end_pos = self.prev().loc.end_pos

        return Ok(TopLevelExpr::StructDef(self.ast_arena.new!(StructDefExpr {
            struct_name: struct_name,
            fields: fields,
            loc: loc,
        })))
    }

    // TODO: implement proper
    if false {}

    let unexpected = self.current()
    let message = String::from_str("Unexpected top level token: ")
    message.push_str(unexpected.get_value(self.lexer.source))

    return Err(self.error_arena.new!(Error {
        message: message,
        loc: unexpected.loc,
    }))
}

fn Parser::parse_fn_def(&self, exported: bool, loc: Loc): Result(&FnDefExpr, &Error) {
    let decl = self.parse_fn_decl()?
    let body = self.parse_code_block()?

    loc.end_pos = self.prev().loc.end_pos

    return Ok(self.ast_arena.new!(FnDefExpr {
        exported: exported,
        decl: decl,
        body: self.ast_arena.new!(body),
        loc: loc,
    }))
}

fn Parser::parse_fn_decl(&self): Result(FnDeclExpr, &Error) {
    let loc = self.prev().loc

    let fn_name = self.parse_ident()?

    let fn_params_trailing_comma = ref!(false)
    let fn_params = self.parse_fn_params(false, fn_params_trailing_comma)?

    let return_type = null as &TypeExpr
    if self.eat(TokenType::Operator, ":") != null {
        return_type = self.ast_arena.new!(self.parse_type_expr()?)
    }

    loc.end_pos = self.prev().loc.end_pos

    return Ok(FnDeclExpr {
        fn_name: fn_name,
        fn_params: fn_params,
        fn_params_trailing_comma: *fn_params_trailing_comma,
        return_type: return_type,
        loc: loc,
    })
}

fn Parser::parse_fn_params(
    &self,
    infer_allowed: bool,
    trailing_comma: &bool,
): Result(&Vec(FnParam), &Error) {
    let params = Vec::new!<FnParam>()

    let _ = self.expect(TokenType::Delim, "(")?

    while self.eat(TokenType::Delim, ")") == null {
        *trailing_comma = false

        let loc = self.current().loc

        let param_type = FnParamType::Self(null)
        if self.eat(TokenType::Operator, "&") != null {
            param_type = FnParamType::SelfRef(null)
        }

        let param_name = self.parse_ident()?
        if !param_name.repr.equals("self") {
            if match FnParamType::SelfRef(_) = param_type {
                return Err(self.error_arena.new!(Error {
                    message: String::from_str("Only `self` param can be preceded by the reference operator"),
                    loc: param_name.loc,
                }))
            }

            let _ = self.expect(TokenType::Operator, ":")?

            if self.eat(TokenType::Symbol, "infer") != null {
                let infer = self.prev()

                if !infer_allowed {
                    return Err(self.error_arena.new!(Error {
                        message: String::from_str("Cannot use `infer` outside macro parameter list"),
                        loc: infer.loc,
                    }))
                }

                let infer_as = self.expect_any(TokenType::Symbol)?
                param_type = FnParamType::Infer(self.ast_arena.new!(FnParamTypeInfer {
                    name: infer_as.get_value(self.source),
                }))
            } else {
                param_type = FnParamType::Type(self.ast_arena.new!(FnParamTypeType {
                    expr: self.parse_type_expr()?,
                }))
            }
        }

        loc.end_pos = self.prev().loc.end_pos

        if !self.current().is(TokenType::Delim, ")", self.source) {
            let _ = self.expect(TokenType::Delim, ",")?
            *trailing_comma = true
        }

        params.push!(FnParam {
            param_name: param_name,
            param_type: param_type,
            loc: loc,
        })
    }

    return Ok(params)
}

fn Parser::parse_memory_def(&self, exported: bool, loc: Loc): Result(MemoryDefExpr, &Error) {
    let params = self.parse_code_expr_map()?
    loc.end_pos = self.prev().loc.end_pos

    return Ok(MemoryDefExpr {
        exported: exported,
        params: params,
        loc: loc,
    })
}

fn Parser::parse_importable(&self): Result(ImportItem, &Error) {
    if self.eat(TokenType::Symbol, "fn") != null {
        let decl = self.parse_fn_decl()?
        return Ok(ImportItem::FnDecl(self.ast_arena.new!(decl)))
    }

    if self.eat(TokenType::Symbol, "memory") != null {
        let loc = self.prev().loc
        let memory_def = self.parse_memory_def(false, loc)?
        return Ok(ImportItem::Memory(self.ast_arena.new!(memory_def)))
    }

    let unexpected = self.current()
    let message = String::from_str_in(
        self.error_arena,
        "Unexpected token in importable item: ",
    )
    message.push_str(unexpected.get_value(self.source))
    return Err(self.error_arena.new!(Error {
        message: message,
        loc: unexpected.loc,
    }))
}

fn Parser::parse_type_expr(&self): Result(TypeExpr, &Error) {
    let loc = self.current().loc
    let primary = self.parse_type_expr_primary()?

    if self.eat(TokenType::Delim, "(") != null {
        let container = primary
        let items = Vec::new!<TypeExpr>()

        while self.eat(TokenType::Delim, ")") == null {
            items.push!(self.parse_type_expr()?)

            if !self.current().is(TokenType::Delim, ")", self.source) {
                let _ = self.expect(TokenType::Delim, ",")?
            }
        }

        loc.end_pos = self.prev().loc.end_pos

        return Ok(TypeExpr::Container(self.ast_arena.new!(TypeExprContainer {
            container: container,
            items: items,
            loc: loc,
        })))
    }

    return Ok(primary)
}

fn Parser::parse_type_expr_primary(&self): Result(TypeExpr, &Error) {
    let loc = self.current().loc

    if self.eat(TokenType::Operator, "&") != null {
        let pointee = self.parse_type_expr()?
        loc.end_pos = self.prev().loc.end_pos
        return Ok(TypeExpr::Pointer(self.ast_arena.new!(TypeExprPointer {
            pointee: pointee,
            loc: loc,
        })))
    }

    // lexer joins two `&` into `&&`
    if self.eat(TokenType::Operator, "&&") != null {
        let pointee = self.parse_type_expr()?
        loc.end_pos = self.prev().loc.end_pos
        return Ok(TypeExpr::Pointer(self.ast_arena.new!(TypeExprPointer {
            pointee: TypeExpr::Pointer(self.ast_arena.new!(TypeExprPointer {
                pointee: pointee,
                loc: loc,
            })),
            loc: loc,
        })))
    }

    if self.eat(TokenType::Operator, "*&") != null {
        let pointee = self.parse_type_expr()?
        loc.end_pos = self.prev().loc.end_pos
        return Ok(TypeExpr::SequencePointer(self.ast_arena.new!(
            TypeExprSequencePointer {
                pointee: pointee,
                loc: loc,
            },
        )))
    }

    let ident = self.parse_ident()?
    return Ok(TypeExpr::Named(self.ast_arena.new!(TypeExprNamed {
        name: ident,
    })))
}

fn Parser::parse_ident(&self): Result(IdentExpr, &Error) {
    let ident = IdentExpr {
        // stub
        repr: "",
        parts: Vec::new!<Loc>(),
        loc: self.current().loc,
    }

    loop {
        let ident_part = self.expect_any(TokenType::Symbol)?
        ident.parts.push!(ident_part.loc)

        if self.eat(TokenType::Operator, "::") == null {
            break
        }
    }

    ident.loc.end_pos = self.prev().loc.end_pos

    ident.repr = ident.loc.read_span(self.source)
    if ident.repr.contains(" ") {
        // TODO: report error
    }

    return Ok(ident)
}

fn Parser::parse_code_expr_map(&self): Result(CodeExprMap, &Error) {
    let fields = Vec::new!<CodeExprMapField>()
    let has_trailing_comma = false

    let loc = self.expect(TokenType::Delim, "{")?.loc

    while self.eat(TokenType::Delim, "}") == null {
        let field_loc = self.current().loc

        let field_name = self.expect_any(TokenType::Symbol)?
        let _ = self.expect(TokenType::Operator, ":")?
        let value = self.parse_code_expr(0)?

        field_loc.end_pos = self.prev().loc.end_pos

        fields.push!(CodeExprMapField {
            key: field_name.get_value(self.source),
            value: value,
            loc: field_loc,
        })

        if !self.current().is(TokenType::Delim, "}", self.source) {
            let _ = self.expect(TokenType::Delim, ",")?
            has_trailing_comma = true
        } else {
            has_trailing_comma = false
        }
    }

    loc.end_pos = self.prev().loc.end_pos

    return Ok(CodeExprMap {
        fields: fields,
        has_trailing_comma: has_trailing_comma,
        loc: loc,
    })
}

fn Parser::parse_code_block(&self): Result(CodeBlock, &Error) {
    let _ = self.expect(TokenType::Delim, "{")?

    let code_block = CodeBlock {
        exprs: Vec::new!<CodeExpr>(),
        loc: self.prev().loc,
    }

    while self.eat(TokenType::Delim, "}") == null {
        let expr = self.parse_code_expr(0)?
        code_block.exprs.push!(expr)
    }

    // closing curly pos
    code_block.loc.end_pos = self.prev().loc.end_pos

    return Ok(code_block)
}

fn Parser::parse_code_expr(&self, min_bp: u32): Result(CodeExpr, &Error) {
    let primary = self.parse_code_expr_primary()?
    let backslash_start_hint = ref!(0)

    while !self.current().is_terminal() {
        let op_symbol = self.current()

        let backslash_between = self.has_backslashes_between(
            backslash_start_hint,
            primary.loc().end_pos.offset,
            op_symbol.loc.pos.offset,
        )

        if op_symbol.loc.pos.line != primary.loc().end_pos.line && !backslash_between {
            break
        }

        let op = InfixOp::parse(op_symbol.get_value(self.source)) catch _ {
            break
        }

        if op.bp < min_bp {
            break
        }

        // skip operator
        let _ = self.next()
        primary = self.parse_code_expr_postfix(primary, op, op_symbol.loc)?
    }

    return Ok(primary)
}

fn Parser::parse_code_expr_primary(&self): Result(CodeExpr, &Error) {
    // TODO: implement proper
    if false {}

    if self.eat_any(TokenType::IntLiteral) != null {
        let int_literal = self.prev()

        let tag = null as &str
        if self.eat(TokenType::Symbol, "u64") != null {
            tag = self.ast_arena.new!(self.prev().get_value(self.lexer.source))
        }

        let repr = int_literal.get_value(self.lexer.source)
        let value = Lexer::parse_int_literal_value(repr)

        return Ok(CodeExpr::IntLiteral(
            self.ast_arena.new!(IntLiteralExpr {
                repr: repr,
                value: value,
                tag: tag,
                loc: int_literal.loc,
            }),
        ))
    }

    if self.eat_any(TokenType::StringLiteral) != null {
        let string = QuotedString::new(self.prev().loc)

        return Ok(CodeExpr::StringLiteral(self.ast_arena.new!(StringLiteralExpr {
            repr: string.get_repr(self.source),
            value: string.get_value(self.source),
            loc: string.loc,
        })))
    }

    if self.eat(TokenType::Symbol, "let") != null {
        let loc = self.prev().loc

        let local_name = self.parse_ident()?
        let _ = self.expect(TokenType::Operator, "=")?
        let value = self.parse_code_expr(0)?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::Let(self.ast_arena.new!(LetExpr {
            local_name: local_name,
            value: value,
            loc: loc,
        })))
    }

    if self.eat(TokenType::Symbol, "if") != null {
        let loc = self.prev().loc

        self.push_ctx(ParsingContext {
            struct_literal_allowed: false,
        })

        let cond = IfCond::Expr(null)
        if self.eat(TokenType::Symbol, "match") != null {
            cond = IfCond::Match(self.ast_arena.new!(self.parse_match_header()?))
        } else {
            cond = IfCond::Expr(self.ast_arena.new!(self.parse_code_expr(0)?))
        }

        self.pop_ctx()

        let then_block = self.parse_code_block()?

        let else_block = ElseBlock::None(null)
        if self.eat(TokenType::Symbol, "else") != null {
            if self.current().is(TokenType::Symbol, "if", self.source) {
                let if_expr = self.parse_code_expr(0)?
                else_block = ElseBlock::ElseIf(self.ast_arena.new!(if_expr))
            } else {
                let block = self.parse_code_block()?
                else_block = ElseBlock::Else(self.ast_arena.new!(block))
            }
        }

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::If(self.ast_arena.new!(IfExpr {
            cond: cond,
            then_block: then_block,
            else_block: else_block,
            loc: loc,
        })))
    }

    if self.eat(TokenType::Symbol, "return") != null {
        let loc = self.prev().loc

        let expr = null as &CodeExpr
        if self.current().loc.end_pos.line == loc.end_pos.line {
            expr = self.ast_arena.new!(self.parse_code_expr(0)?)
        }

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::Return(
            self.ast_arena.new!(ReturnExpr {
                expr: expr,
                loc: loc,
            }),
        ))
    }

    if self.eat(TokenType::Operator, "@") != null {
        let loc = self.prev().loc

        let fn_name = self.parse_ident()?
        let type_args = self.parse_macro_type_args()?
        let args = self.parse_fn_args()?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::IntrinsicCall(self.ast_arena.new!(MacroFnCallExpr {
            fn_name: fn_name,
            type_args: type_args,
            args: args,
            loc: loc,
        })))
    }

    // TODO: implement proper
    if false {}

    let op_token = self.current()
    if !op_token.is_terminal() {
        let maybe_op = PrefixOp::parse(op_token.get_value(self.source))
        if @get_err(maybe_op) == null {
            let op = @get_ok(maybe_op)
            if op.tag != PrefixOpTag::Reference \
                && op.tag != PrefixOpTag::Dereference \
                && op.tag != PrefixOpTag::Not \
                && op.tag != PrefixOpTag::Positive \
                && op.tag != PrefixOpTag::Negative
            {
                @unreachable()
            }

            // skip operator
            let loc = self.next().loc

            let expr = self.parse_code_expr(op.bp_next)?

            loc.end_pos = self.prev().loc.end_pos

            return Ok(CodeExpr::PrefixOp(self.ast_arena.new!(PrefixOpExpr {
                op_tag: op.tag,
                expr: expr,
                op_loc: op_token.loc,
                loc: loc,
            })))
        }
    }

    let ident = self.parse_ident()?

    // TODO: implement proper
    if false {}

    if self.current().is(TokenType::Delim, "(", self.source) {
        let loc = ident.loc

        self.push_ctx(ParsingContext {
            struct_literal_allowed: true,
        })

        let args = self.parse_fn_args()?

        self.pop_ctx()

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::FnCall(self.ast_arena.new!(FnCallExpr {
            fn_name: ident,
            args: args,
            loc: loc,
        })))
    }

    return Ok(CodeExpr::Ident(self.ast_arena.new!(ident)))
}

fn Parser::parse_code_expr_postfix(
    &self,
    primary: CodeExpr,
    op: InfixOp,
    op_loc: Loc,
): Result(CodeExpr, &Error) {
    if op.tag == InfixOpTag::Equal \
        || op.tag == InfixOpTag::NotEqual \
        || op.tag == InfixOpTag::Less \
        || op.tag == InfixOpTag::Greater \
        || op.tag == InfixOpTag::LessEqual \
        || op.tag == InfixOpTag::GreaterEqual \
        || op.tag == InfixOpTag::Add \
        || op.tag == InfixOpTag::Sub \
        || op.tag == InfixOpTag::Mul \
        || op.tag == InfixOpTag::Div \
        || op.tag == InfixOpTag::Mod \
        || op.tag == InfixOpTag::And \
        || op.tag == InfixOpTag::BitAnd \
        || op.tag == InfixOpTag::Or \
        || op.tag == InfixOpTag::BitOr \
        || op.tag == InfixOpTag::ShiftLeft \
        || op.tag == InfixOpTag::ShiftRight \
        || op.tag == InfixOpTag::AddAssign \
        || op.tag == InfixOpTag::SubAssign \
        || op.tag == InfixOpTag::MulAssign \
        || op.tag == InfixOpTag::DivAssign \
        || op.tag == InfixOpTag::ModAssign \
        || op.tag == InfixOpTag::BitAndAssign \
        || op.tag == InfixOpTag::BitOrAssign \
        || op.tag == InfixOpTag::ShiftLeftAssign \
        || op.tag == InfixOpTag::ShiftRightAssign
    {
        let lhs = primary
        let rhs = self.parse_code_expr(op.bp_next)?

        let loc = lhs.loc()
        loc.end_pos = rhs.loc().end_pos

        return Ok(CodeExpr::InfixOp(self.ast_arena.new!(InfixOpExpr {
            op_tag: op.tag,
            op_loc: op_loc,
            lhs: lhs,
            rhs: rhs,
            loc: loc,
        })))
    }

    if op.tag == InfixOpTag::Cast {
        let loc = primary.loc()

        let casted_to = self.parse_type_expr()?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::Cast(self.ast_arena.new!(CastExpr {
            expr: primary,
            casted_to: casted_to,
            loc: loc,
        })))
    }

    if op.tag == InfixOpTag::FieldAccess {
        todo!(dbg "")
    }

    if op.tag == InfixOpTag::Assign {
        let loc = primary.loc()

        let value = self.parse_code_expr(op.bp_next)?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::Assign(self.ast_arena.new!(AssignExpr {
            op_loc: op_loc,
            lhs: primary,
            rhs: value,
            loc: loc,
        })))
    }

    if op.tag == InfixOpTag::Catch {
        todo!(dbg "")
    }

    if op.tag == InfixOpTag::ErrorPropagation {
        todo!(dbg "")
    }

    if op.tag == InfixOpTag::ExprPipe {
        todo!(dbg "")
    }

    return Err(self.error_arena.new!(Error {
        message: String::from_str("TODO"),
        loc: op_loc,
    }))
}

fn Parser::parse_fn_args(&self): Result(CodeExprList, &Error) {
    let has_trailing_comma = false
    let items = Vec::new!<CodeExpr>()

    let _ = self.expect(TokenType::Delim, "(")?
    while self.eat(TokenType::Delim, ")") == null {
        items.push!(self.parse_code_expr(0)?)

        if !self.current().is(TokenType::Delim, ")", self.source) {
            let _ = self.expect(TokenType::Delim, ",")?
            has_trailing_comma = true
        } else {
            has_trailing_comma = false
        }
    }

    return Ok(CodeExprList {
        items: items,
        has_trailing_comma: has_trailing_comma,
    })
}

fn Parser::parse_macro_type_args(&self): Result(&Vec(TypeExpr), &Error) {
    let type_args = Vec::new!<TypeExpr>()

    if self.eat(TokenType::Operator, "<") == null {
        return Ok(type_args)
    }

    while self.eat(TokenType::Operator, ">") == null {
        type_args.push!(self.parse_type_expr()?)

        if !self.current().is(TokenType::Operator, ">", self.source) {
            let _ = self.expect(TokenType::Delim, ",")?
        }
    }

    return Ok(type_args)
}

fn Parser::parse_match_header(&self): Result(MatchHeader, &Error) {
    todo!(dbg "")
}

fn Parser::has_backslashes_between(
    &self,
    start_hint: &u32,
    offset_start: u32,
    offset_end: u32,
): bool {
    let i = *start_hint

    while i < self.lexer.backslashes.size {
        let backslash = self.lexer.backslashes.at!(i)
        if backslash.pos.offset < offset_start {
            i += 1
            continue
        }

        *start_hint = i
        return backslash.end_pos.offset <= offset_end
    }

    *start_hint = i
    return false
}

// utils

fn Parser::push_ctx(&self, ctx: ParsingContext) {
    self.context_stack.push!(ctx)
}

fn Parser::pop_ctx(&self) {
    self.context_stack.pop()
}

fn Parser::expect(&self, type_: TokenType, value: str): Result(&Token, &Error) {
    let token = self.current()
    if !token.is(type_, value, self.lexer.source) {
        let message = String::from_str_in(
            self.error_arena,
            "Unexpected token '",
        )
        message.push_str(token.get_value(self.lexer.source))
        message.push_str("', wanted '")
        message.push_str(value)
        message.push_str("'")

        return Err(self.error_arena.new!(Error {
            message: message,
            loc: token.loc,
        }))
    }

    return Ok(self.next())
}

fn Parser::expect_any(&self, type_: TokenType): Result(&Token, &Error) {
    let token = self.current()
    if !token.is_any(type_) {
        let message = String::from_str_in(
            self.error_arena,
            "Unexpected token '",
        )
        message.push_str(token.get_value(self.lexer.source))
        message.push_str("', wanted '")
        message.push_str(type_.to_str())
        message.push_str("'")

        return Err(self.error_arena.new!(Error {
            message: message,
            loc: token.loc,
        }))
    }

    return Ok(self.next())
}

fn Parser::eat(&self, type_: TokenType, value: str): &Token {
    if !self.current().is(type_, value, self.lexer.source) {
        return null
    }

    return self.next()
}

fn Parser::eat_any(&self, type_: TokenType): &Token {
    if !self.current().is_any(type_) {
        return null
    }

    return self.next()
}

// returns current or terminal token
fn Parser::current(&self): &Token {
    let index = self.tokens_processed
    if index >= self.lexer.tokens.size - 1 {
        index = self.lexer.tokens.size - 1
    }

    return self.lexer.tokens.at!(index)
}

fn Parser::prev(&self): &Token {
    return self.lexer.tokens.at!(self.tokens_processed - 1)
}

fn Parser::next(&self): &Token {
    let token = self.current()
    self.tokens_processed += 1
    return token
}
