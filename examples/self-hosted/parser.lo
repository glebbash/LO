include "./core.lo"
include "./lexer.lo"
include "./ast.lo"

// TODO?: support `use TokenType::*`
inline let StringLiteral = TokenType::StringLiteral
inline let CharLiteral = TokenType::CharLiteral
inline let IntLiteral = TokenType::IntLiteral
inline let Symbol = TokenType::Symbol
inline let Delim = TokenType::Delim
inline let Operator = TokenType::Operator
inline let Terminal = TokenType::Terminal

struct ParsingContext {
    struct_literal_allowed: bool,
}

struct Parser {
    // context
    error_arena: &Arena,
    lexer: &Lexer,
    source: str,

    // state
    tokens_processed: u32,
    context_stack: &Vec(ParsingContext),

    // output
    ast_arena: &Arena,
    ast: &Vec(TopLevelExpr),
}

fn Parser::new(lexer: &Lexer): &Parser {
    let context_stack = Vec::new!<ParsingContext>()
    context_stack.push!(ParsingContext {
        struct_literal_allowed: true,
    })

    return heap::new!(Parser {
        error_arena: lexer.error_arena,
        lexer: lexer,
        source: lexer.source,
        tokens_processed: 0,
        context_stack: context_stack,

        ast_arena: Arena::new(512),
        ast: Vec::new!<TopLevelExpr>(),
    })
}

fn Parser::free(&self) {
    self.lexer.free()
    self.context_stack.free()
    self.ast_arena.free()
    self.ast.free()
    heap::free(self)
}

fn Parser::parse_file(&self): Result(void, &Error) {
    while !self.current().is_terminal() {
        let expr = self.parse_top_level_expr()?
        self.ast.push!(expr)
    }

    return Ok()
}

fn Parser::parse_top_level_expr(&self): Result(TopLevelExpr, &Error) {
    if self.eat(Symbol, "export") != null {
        let loc = self.prev().loc

        if self.eat(Symbol, "fn") != null {
            let fn_def = self.parse_fn_def(true, loc)?
            return Ok(TopLevelExpr::FnDef(fn_def))
        }

        if self.eat(Symbol, "memory") != null {
            let memory_def = self.parse_memory_def(true, loc)?
            return Ok(TopLevelExpr::MemoryDef(self.ast_arena.new!(memory_def)))
        }

        let unexpected = self.current()
        let message = String::from_str_in(self.error_arena, "Unexpected exportable: ")
        message.push_str(unexpected.get_value(self.lexer.source))

        return Err(self.error_arena.new!(Error {
            message: message,
            loc: unexpected.loc,
        }))
    }

    if self.eat(Operator, "@") != null {
        let loc = self.prev().loc

        let fn_name = self.parse_ident()?
        let type_args = self.parse_macro_type_args()?
        let args = self.parse_fn_args()?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(TopLevelExpr::IntrinsicCall(self.ast_arena.new!(MacroFnCallExpr {
            fn_name: fn_name,
            type_args: type_args,
            args: args,
            loc: loc,
        })))
    }

    if self.eat(Symbol, "fn") != null {
        let fn_def = self.parse_fn_def(false, self.prev().loc)?
        return Ok(TopLevelExpr::FnDef(fn_def))
    }

    if self.eat(Symbol, "memory") != null {
        let memory_def = self.parse_memory_def(false, self.prev().loc)?
        return Ok(TopLevelExpr::MemoryDef(self.ast_arena.new!(memory_def)))
    }

    if self.eat(Symbol, "include") != null {
        let loc = self.prev().loc

        let file_path = self.expect_any(StringLiteral)?
        let alias = null as &IdentExpr
        if self.eat(Symbol, "as") != null {
            alias = self.ast_arena.new!(self.parse_ident()?)
        }

        let with_extern = false
        if self.eat(Symbol, "with") != null {
            let _ = self.expect(Symbol, "extern")?
            with_extern = true
        }

        loc.end_pos = self.prev().loc.end_pos

        return Ok(TopLevelExpr::Include(self.ast_arena.new!(IncludeExpr {
            file_path: QuotedString::new(file_path.loc),
            alias: alias,
            with_extern: with_extern,
            loc: loc,
        })))
    }

    if self.eat(Symbol, "import") != null {
        let loc = self.prev().loc

        let _ = self.expect(Symbol, "from")?
        let module_name = self.expect_any(StringLiteral)?

        let _ = self.expect(Delim, "{")?

        let items = Vec::new!<ImportItem>()
        while self.eat(Delim, "}") == null {
            let item = self.parse_importable()?
            items.push!(item)
        }

        loc.end_pos = self.prev().loc.end_pos

        return Ok(TopLevelExpr::Import(self.ast_arena.new!(ImportExpr {
            module_name: QuotedString::new(module_name.loc),
            items: items,
            loc: loc,
        })))
    }

    if self.eat(Symbol, "let") != null {
        let loc = self.prev().loc

        let global_name = self.parse_ident()?
        let _ = self.expect(Operator, "=")?
        let global_value = self.parse_code_expr(0)?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(TopLevelExpr::GlobalDef(self.ast_arena.new!(GlobalDefExpr {
            global_name: global_name,
            global_value: global_value,
            loc: loc,
        })))
    }

    if self.eat(Symbol, "inline") != null {
        let loc = self.prev().loc

        let _ = self.expect(Symbol, "let")?
        let const_name = self.parse_ident()?
        let _ = self.expect(Operator, "=")?
        let const_value = self.parse_code_expr(0)?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(TopLevelExpr::ConstDef(self.ast_arena.new!(ConstDefExpr {
            const_name: const_name,
            const_value: const_value,
            loc: loc,
        })))
    }

    if self.eat(Symbol, "struct") != null {
        let loc = self.prev().loc

        let struct_name = self.parse_ident()?

        let fields = Vec::new!<StructDefField>()

        let _ = self.expect(Delim, "{")?
        while self.eat(Delim, "}") == null {
            let field_loc = self.current().loc

            let field_name = self.parse_ident()?
            let _ = self.expect(Operator, ":")?
            let field_type = self.parse_type_expr()?

            field_loc.end_pos = self.prev().loc.end_pos

            fields.push!(StructDefField {
                field_name: field_name,
                field_type: field_type,
                loc: field_loc,
            })

            if !self.current().is(Delim, "}", self.source) {
                let _ = self.expect(Delim, ",")?
            }
        }

        loc.end_pos = self.prev().loc.end_pos

        return Ok(TopLevelExpr::StructDef(self.ast_arena.new!(StructDefExpr {
            struct_name: struct_name,
            fields: fields,
            loc: loc,
        })))
    }

    if self.eat(Symbol, "enum") != null {
        let loc = self.prev().loc

        let enum_name = self.parse_ident()?

        let variant_type = null as &TypeExpr
        if self.eat(Delim, "(") != null {
            variant_type = self.ast_arena.new!(self.parse_type_expr()?)
            let _ = self.expect(Delim, ")")?
        }

        let variants = Vec::new!<EnumDefVariant>()

        let _ = self.expect(Delim, "{")?
        while self.eat(Delim, "}") == null {
            let variant_loc = self.current().loc

            let variant_name = self.parse_ident()?

            let variant_type = null as &TypeExpr
            if self.eat(Delim, "(") != null {
                variant_type = self.ast_arena.new!(self.parse_type_expr()?)
                let _ = self.expect(Delim, ")")?
            }

            variant_loc.end_pos = self.prev().loc.end_pos

            variants.push!(EnumDefVariant {
                variant_name: variant_name,
                variant_type: variant_type,
                loc: variant_loc,
            })

            if !self.current().is(Delim, "}", self.source) {
                let _ = self.expect(Delim, ",")?
            }
        }

        loc.end_pos = self.prev().loc.end_pos

        return Ok(TopLevelExpr::EnumDef(self.ast_arena.new!(EnumDefExpr {
            enum_name: enum_name,
            variant_type: variant_type,
            variants: variants,
            loc: loc,
        })))
    }

    if self.eat(Symbol, "type") != null {
        let loc = self.prev().loc

        let type_name = self.parse_ident()?
        let _ = self.expect(Operator, "=")?
        let type_value = self.parse_type_expr()?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(TopLevelExpr::TypeDef(self.ast_arena.new!(TypeDefExpr {
            type_name: type_name,
            type_value: type_value,
            loc: loc,
        })))
    }

    if self.eat(Symbol, "macro") != null {
        let loc = self.prev().loc

        let macro_name = self.parse_ident()?
        let _ = self.expect(Operator, "!")?
        let excl_end_pos = self.prev().loc.end_pos

        let macro_type_params = Vec::new!<str>()
        if self.eat(Operator, "<") != null {
            while self.eat(Operator, ">") == null {
                let type_param = self.expect_any(Symbol)?
                macro_type_params.push!(type_param.get_value(self.source))

                if !self.current().is(Operator, ">", self.source) {
                    let _ = self.expect(Delim, ",")?
                }
            }
        }

        let macro_params_trailing_comma = ref!(false)
        let macro_params = self.parse_fn_params(macro_params_trailing_comma)?

        let return_type = null as &TypeExpr
        if self.eat(Operator, ":") != null {
            return_type = self.ast_arena.new!(self.parse_type_expr()?)
        }

        let body = self.parse_code_block()?

        loc.end_pos = self.prev().loc.end_pos

        let result = self.ast_arena.new!(MacroDefExpr {
            macro_name: macro_name,
            macro_params: macro_params,
            macro_params_trailing_comma: *macro_params_trailing_comma,
            macro_type_params: macro_type_params,
            return_type: return_type,
            body: body,
            loc: loc,
        })

        self.extend_ident(&result.macro_name, excl_end_pos)

        return Ok(TopLevelExpr::MacroDef(result))
    }

    let unexpected = self.current()
    let message = String::from_str_in(self.error_arena, "Unexpected top level token: ")
    message.push_str(unexpected.get_value(self.lexer.source))

    return Err(self.error_arena.new!(Error {
        message: message,
        loc: unexpected.loc,
    }))
}

fn Parser::parse_fn_def(&self, exported: bool, loc: Loc): Result(&FnDefExpr, &Error) {
    let decl = self.parse_fn_decl()?
    let body = self.parse_code_block()?

    loc.end_pos = self.prev().loc.end_pos

    return Ok(self.ast_arena.new!(FnDefExpr {
        exported: exported,
        decl: decl,
        body: self.ast_arena.new!(body),
        loc: loc,
    }))
}

fn Parser::parse_fn_decl(&self): Result(FnDeclExpr, &Error) {
    let loc = self.prev().loc

    let fn_name = self.parse_ident()?

    let fn_params_trailing_comma = ref!(false)
    let fn_params = self.parse_fn_params(fn_params_trailing_comma)?

    let return_type = null as &TypeExpr
    if self.eat(Operator, ":") != null {
        return_type = self.ast_arena.new!(self.parse_type_expr()?)
    }

    loc.end_pos = self.prev().loc.end_pos

    return Ok(FnDeclExpr {
        fn_name: fn_name,
        fn_params: fn_params,
        fn_params_trailing_comma: *fn_params_trailing_comma,
        return_type: return_type,
        loc: loc,
    })
}

fn Parser::parse_fn_params(
    &self, \\ trailing_comma: &bool,
): Result(&Vec(FnParam), &Error) {
    let params = Vec::new!<FnParam>()

    let _ = self.expect(Delim, "(")?

    while self.eat(Delim, ")") == null {
        *trailing_comma = false

        let loc = self.current().loc

        let param_type = FnParamType::Self(null)
        if self.eat(Operator, "&") != null {
            param_type = FnParamType::SelfRef(null)
        }

        let param_name = self.parse_ident()?
        if self.eat(Operator, ":") != null {
            param_type = FnParamType::Type(self.ast_arena.new!(FnParamTypeType {
                expr: self.parse_type_expr()?,
            }))
        }

        loc.end_pos = self.prev().loc.end_pos

        if !self.current().is(Delim, ")", self.source) {
            let _ = self.expect(Delim, ",")?
            *trailing_comma = true
        }

        params.push!(FnParam {
            param_name: param_name,
            param_type: param_type,
            loc: loc,
        })
    }

    return Ok(params)
}

fn Parser::parse_memory_def(&self, exported: bool, loc: Loc): Result(MemoryDefExpr, &Error) {
    let params = self.parse_code_expr_map()?
    loc.end_pos = self.prev().loc.end_pos

    return Ok(MemoryDefExpr {
        exported: exported,
        params: params,
        loc: loc,
    })
}

fn Parser::parse_importable(&self): Result(ImportItem, &Error) {
    if self.eat(Symbol, "fn") != null {
        let decl = self.parse_fn_decl()?
        return Ok(ImportItem::FnDecl(self.ast_arena.new!(decl)))
    }

    if self.eat(Symbol, "memory") != null {
        let loc = self.prev().loc
        let memory_def = self.parse_memory_def(false, loc)?
        return Ok(ImportItem::Memory(self.ast_arena.new!(memory_def)))
    }

    let unexpected = self.current()
    let message = String::from_str_in(
        self.error_arena,
        "Unexpected token in importable item: ",
    )
    message.push_str(unexpected.get_value(self.source))
    return Err(self.error_arena.new!(Error {
        message: message,
        loc: unexpected.loc,
    }))
}

fn Parser::parse_type_expr(&self): Result(TypeExpr, &Error) {
    let loc = self.current().loc
    let primary = self.parse_type_expr_primary()?

    if self.eat(Delim, "(") != null {
        let container = primary
        let items = Vec::new!<TypeExpr>()

        while self.eat(Delim, ")") == null {
            items.push!(self.parse_type_expr()?)

            if !self.current().is(Delim, ")", self.source) {
                let _ = self.expect(Delim, ",")?
            }
        }

        loc.end_pos = self.prev().loc.end_pos

        return Ok(TypeExpr::Container(self.ast_arena.new!(TypeExprContainer {
            container: container,
            items: items,
            loc: loc,
        })))
    }

    return Ok(primary)
}

fn Parser::parse_type_expr_primary(&self): Result(TypeExpr, &Error) {
    let loc = self.current().loc

    if self.eat(Operator, "&") != null {
        let pointee = self.parse_type_expr()?
        loc.end_pos = self.prev().loc.end_pos
        return Ok(TypeExpr::Pointer(self.ast_arena.new!(TypeExprPointer {
            pointee: pointee,
            loc: loc,
        })))
    }

    // lexer joins two `&` into `&&`
    if self.eat(Operator, "&&") != null {
        let pointee = self.parse_type_expr()?
        loc.end_pos = self.prev().loc.end_pos
        return Ok(TypeExpr::Pointer(self.ast_arena.new!(TypeExprPointer {
            pointee: TypeExpr::Pointer(self.ast_arena.new!(TypeExprPointer {
                pointee: pointee,
                loc: loc,
            })),
            loc: loc,
        })))
    }

    if self.eat(Operator, "*&") != null {
        let pointee = self.parse_type_expr()?
        loc.end_pos = self.prev().loc.end_pos
        return Ok(TypeExpr::SequencePointer(self.ast_arena.new!(
            TypeExprSequencePointer {
                pointee: pointee,
                loc: loc,
            },
        )))
    }

    let ident = self.parse_ident()?
    return Ok(TypeExpr::Named(self.ast_arena.new!(TypeExprNamed {
        name: ident,
    })))
}

fn Parser::parse_ident(&self): Result(IdentExpr, &Error) {
    let ident = IdentExpr {
        // stub
        repr: "",
        parts: Vec::new!<Loc>(),
        loc: self.current().loc,
    }

    loop {
        let ident_part = self.expect_any(Symbol)?
        ident.parts.push!(ident_part.loc)

        if self.eat(Operator, "::") == null {
            break
        }
    }

    ident.loc.end_pos = self.prev().loc.end_pos

    ident.repr = ident.loc.read_span(self.source)
    if ident.repr.contains(" ") {
        // TODO: report error this error instead of throwing
        return Err(self.error_arena.new!(Error {
            message: String::from_str_in(self.error_arena, "Unexpected space in identifier"),
            loc: ident.loc,
        }))
    }

    return Ok(ident)
}

fn Parser::parse_code_expr_map(&self): Result(CodeExprMap, &Error) {
    let fields = Vec::new!<CodeExprMapField>()
    let has_trailing_comma = false

    let loc = self.expect(Delim, "{")?.loc

    while self.eat(Delim, "}") == null {
        let field_loc = self.current().loc

        let field_name = self.expect_any(Symbol)?
        let _ = self.expect(Operator, ":")?
        let value = self.parse_code_expr(0)?

        field_loc.end_pos = self.prev().loc.end_pos

        fields.push!(CodeExprMapField {
            key: field_name.get_value(self.source),
            value: value,
            loc: field_loc,
        })

        if !self.current().is(Delim, "}", self.source) {
            let _ = self.expect(Delim, ",")?
            has_trailing_comma = true
        } else {
            has_trailing_comma = false
        }
    }

    loc.end_pos = self.prev().loc.end_pos

    return Ok(CodeExprMap {
        fields: fields,
        has_trailing_comma: has_trailing_comma,
        loc: loc,
    })
}

fn Parser::parse_code_block(&self): Result(CodeBlock, &Error) {
    let _ = self.expect(Delim, "{")?

    let code_block = CodeBlock {
        exprs: Vec::new!<CodeExpr>(),
        loc: self.prev().loc,
    }

    while self.eat(Delim, "}") == null {
        let expr = self.parse_code_expr(0)?
        code_block.exprs.push!(expr)
    }

    // closing curly pos
    code_block.loc.end_pos = self.prev().loc.end_pos

    return Ok(code_block)
}

fn Parser::parse_code_expr(&self, min_bp: u32): Result(CodeExpr, &Error) {
    let primary = self.parse_code_expr_primary()?
    let backslash_start_hint = ref!(0)

    while !self.current().is_terminal() {
        let op_symbol = self.current()

        let backslash_between = self.has_backslashes_between(
            backslash_start_hint,
            primary.loc().end_pos.offset,
            op_symbol.loc.pos.offset,
        )

        if op_symbol.loc.pos.line != primary.loc().end_pos.line && !backslash_between {
            break
        }

        let op = InfixOp::parse(op_symbol.get_value(self.source)) catch _ {
            break
        }

        if op.bp < min_bp {
            break
        }

        // skip operator
        let _ = self.next()
        primary = self.parse_code_expr_postfix(primary, op, op_symbol.loc)?
    }

    return Ok(primary)
}

fn Parser::parse_code_expr_primary(&self): Result(CodeExpr, &Error) {
    if self.eat(Symbol, "true") != null {
        let loc = self.prev().loc

        return Ok(CodeExpr::BoolLiteral(self.ast_arena.new!(
            BoolLiteralExpr { value: true, loc: loc },
        )))
    }

    if self.eat(Symbol, "false") != null {
        let loc = self.prev().loc

        return Ok(CodeExpr::BoolLiteral(self.ast_arena.new!(
            BoolLiteralExpr { value: false, loc: loc },
        )))
    }

    if self.eat(Symbol, "null") != null {
        let loc = self.prev().loc

        return Ok(CodeExpr::NullLiteral(self.ast_arena.new!(
            NullLiteralExpr { loc: loc },
        )))
    }

    if self.eat_any(CharLiteral) != null {
        let char = self.prev()
        return Ok(CodeExpr::CharLiteral(self.ast_arena.new!(CharLiteralExpr {
            repr: char.get_value(self.source),
            value: Lexer::parse_char_literal_value(char.get_value(self.source)) as u32,
            loc: char.loc,
        })))
    }

    if self.eat_any(IntLiteral) != null {
        let int_literal = self.prev()

        let tag = null as &str
        if self.eat(Symbol, "u64") != null {
            tag = self.ast_arena.new!(self.prev().get_value(self.lexer.source))
        }

        let repr = int_literal.get_value(self.lexer.source)
        let value = Lexer::parse_int_literal_value(repr)

        return Ok(CodeExpr::IntLiteral(
            self.ast_arena.new!(IntLiteralExpr {
                repr: repr,
                value: value,
                tag: tag,
                loc: int_literal.loc,
            }),
        ))
    }

    if self.eat_any(StringLiteral) != null {
        let string = QuotedString::new(self.prev().loc)

        return Ok(CodeExpr::StringLiteral(self.ast_arena.new!(StringLiteralExpr {
            repr: string.get_repr(self.source),
            value: string.get_value(self.source),
            loc: string.loc,
        })))
    }

    if self.eat(Delim, "(") != null {
        let loc = self.prev().loc

        self.push_ctx(ParsingContext { struct_literal_allowed: true })
        let expr = self.parse_code_expr(0)?
        self.pop_ctx()

        let has_trailing_comma = self.eat(Delim, ",") != null
        let _ = self.expect(Delim, ")")?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::Paren(self.ast_arena.new!(ParenExpr {
            expr: expr,
            has_trailing_comma: has_trailing_comma,
            loc: loc,
        })))
    }

    if self.eat(Symbol, "let") != null {
        let loc = self.prev().loc

        let local_name = self.parse_ident()?
        let _ = self.expect(Operator, "=")?
        let value = self.parse_code_expr(0)?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::Let(self.ast_arena.new!(LetExpr {
            local_name: local_name,
            value: value,
            loc: loc,
        })))
    }

    if self.eat(Symbol, "return") != null {
        let loc = self.prev().loc

        let expr = null as &CodeExpr
        if self.current().loc.end_pos.line == loc.end_pos.line {
            expr = self.ast_arena.new!(self.parse_code_expr(0)?)
        }

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::Return(
            self.ast_arena.new!(ReturnExpr {
                expr: expr,
                loc: loc,
            }),
        ))
    }

    if self.eat(Symbol, "if") != null {
        let loc = self.prev().loc

        self.push_ctx(ParsingContext {
            struct_literal_allowed: false,
        })

        let cond = IfCond::Expr(null)
        if self.eat(Symbol, "match") != null {
            cond = IfCond::Match(self.ast_arena.new!(self.parse_match_header()?))
        } else {
            cond = IfCond::Expr(self.ast_arena.new!(self.parse_code_expr(0)?))
        }

        self.pop_ctx()

        let then_block = self.parse_code_block()?

        let else_block = ElseBlock::None(null)
        if self.eat(Symbol, "else") != null {
            if self.current().is(Symbol, "if", self.source) {
                let if_expr = self.parse_code_expr(0)?
                else_block = ElseBlock::ElseIf(self.ast_arena.new!(if_expr))
            } else {
                let block = self.parse_code_block()?
                else_block = ElseBlock::Else(self.ast_arena.new!(block))
            }
        }

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::If(self.ast_arena.new!(IfExpr {
            cond: cond,
            then_block: then_block,
            else_block: else_block,
            loc: loc,
        })))
    }

    if self.eat(Symbol, "match") != null {
        let loc = self.prev().loc

        let match_header = self.parse_match_header()?
        let _ = self.expect(Symbol, "else")?
        let else_branch = self.parse_code_block()?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::Match(self.ast_arena.new!(MatchExpr {
            header: match_header,
            else_branch: else_branch,
            loc: loc,
        })))
    }

    if self.eat(Symbol, "loop") != null {
        let loc = self.prev().loc

        let body = self.parse_code_block()?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::While(self.ast_arena.new!(WhileExpr {
            cond: null,
            body: body,
            loc: loc,
        })))
    }

    if self.eat(Symbol, "while") != null {
        let loc = self.prev().loc

        self.push_ctx(ParsingContext { struct_literal_allowed: false })
        let cond = self.parse_code_expr(0)?
        self.pop_ctx()

        let body = self.parse_code_block()?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::While(self.ast_arena.new!(WhileExpr {
            cond: self.ast_arena.new!(cond),
            body: body,
            loc: loc,
        })))
    }

    if self.eat(Symbol, "for") != null {
        let loc = self.prev().loc

        self.push_ctx(ParsingContext { struct_literal_allowed: false })
        let counter = self.parse_ident()?
        let _ = self.expect(Symbol, "in")?
        let start = self.parse_code_expr(0)?
        let op = self.expect(Operator, "..")?
        let end = self.parse_code_expr(0)?
        self.pop_ctx()

        let body = self.parse_code_block()?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::For(self.ast_arena.new!(ForExpr {
            counter: counter,
            start: start,
            end: end,
            body: body,
            op_loc: op.loc,
            loc: loc,
        })))
    }

    if self.eat(Symbol, "break") != null {
        let loc = self.prev().loc

        return Ok(CodeExpr::Break(self.ast_arena.new!(
            BreakExpr { loc: loc },
        )))
    }

    if self.eat(Symbol, "continue") != null {
        let loc = self.prev().loc

        return Ok(CodeExpr::Continue(self.ast_arena.new!(
            ContinueExpr { loc: loc },
        )))
    }

    if self.eat(Symbol, "do") != null {
        let loc = self.prev().loc

        let body = self.parse_code_expr(0)?
        let with_ = self.expect(Symbol, "with")?
        let args = self.parse_fn_args()?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::DoWith(self.ast_arena.new!(DoWithExpr {
            body: body,
            args: args,
            with_loc: with_.loc,
            loc: loc,
        })))
    }

    if self.eat(Operator, "@") != null {
        let loc = self.prev().loc

        let fn_name = self.parse_ident()?
        let type_args = self.parse_macro_type_args()?
        let args = self.parse_fn_args()?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::IntrinsicCall(self.ast_arena.new!(MacroFnCallExpr {
            fn_name: fn_name,
            type_args: type_args,
            args: args,
            loc: loc,
        })))
    }

    if self.eat(Symbol, "defer") != null {
        let loc = self.prev().loc

        let expr = self.parse_code_expr(0)?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::Defer(self.ast_arena.new!(DeferExpr {
            expr: expr,
            loc: loc,
        })))
    }

    if self.eat(Symbol, "sizeof") != null {
        let loc = self.prev().loc

        let type_expr = self.parse_type_expr()?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::Sizeof(self.ast_arena.new!(SizeofExpr {
            type_expr: type_expr,
            loc: loc,
        })))
    }

    if self.eat(Delim, "[") != null {
        let loc = self.prev().loc

        let item_type = self.parse_type_expr()?
        let _ = self.expect(Delim, "]")?

        let has_trailing_comma = false

        let _ = self.expect(Delim, "[")?
        let items = Vec::new!<CodeExpr>()
        while self.eat(Delim, "]") == null {
            let item = self.parse_code_expr(0)?
            items.push!(item)

            if !self.current().is(Delim, "]", self.source) {
                let _ = self.expect(Delim, ",")?
                has_trailing_comma = true
            } else {
                has_trailing_comma = false
            }
        }

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::ArrayLiteral(self.ast_arena.new!(ArrayLiteralExpr {
            item_type: item_type,
            items: items,
            has_trailing_comma: has_trailing_comma,
            loc: loc,
        })))
    }

    if self.eat(Operator, ":") != null || self.eat(Delim, "{") != null {
        let message = String::from_str_in(self.error_arena, "Unexpected character '")
        message.push_str(self.prev().get_value(self.source))
        message.push_str("'.\nIf you were trying to create a struct in this context surround it with parens.")

        return Err(self.error_arena.new!(Error {
            message: message,
            loc: self.prev().loc,
        }))
    }

    let op_token = self.current()
    if !op_token.is_terminal() {
        let maybe_op = PrefixOp::parse(op_token.get_value(self.source))
        if @get_err(maybe_op) == null {
            let op = @get_ok(maybe_op)
            if op.tag != PrefixOpTag::Reference \
                && op.tag != PrefixOpTag::Dereference \
                && op.tag != PrefixOpTag::Not \
                && op.tag != PrefixOpTag::Positive \
                && op.tag != PrefixOpTag::Negative
            {
                @unreachable()
            }

            // skip operator
            let loc = self.next().loc

            let expr = self.parse_code_expr(op.bp_next)?

            loc.end_pos = self.prev().loc.end_pos

            return Ok(CodeExpr::PrefixOp(self.ast_arena.new!(PrefixOpExpr {
                op_tag: op.tag,
                expr: expr,
                op_loc: op_token.loc,
                loc: loc,
            })))
        }
    }

    let ident = self.parse_ident()?

    if ident.repr.equals("Ok") || ident.repr.equals("Err") {
        let loc = ident.loc

        let result_type = null as &ResultTypeExpr
        if self.eat(Operator, ":") != null {
            let _ = self.expect(Operator, "<")?
            let ok = self.parse_type_expr()?
            let _ = self.expect(Delim, ",")?
            let err = self.parse_type_expr()?
            let _ = self.expect(Operator, ">")?

            result_type = self.ast_arena.new!(ResultTypeExpr { ok: ok, err: err })
        }

        let _ = self.expect(Delim, "(")?
        let value = null as &CodeExpr
        if self.eat(Delim, ")") == null {
            value = self.ast_arena.new!(self.parse_code_expr(0)?)
            let _ = self.expect(Delim, ")")?
        }

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::ResultLiteral(self.ast_arena.new!(ResultLiteralExpr {
            is_ok: ident.repr.equals("Ok"),
            result_type: result_type,
            value: value,
            loc: loc,
        })))
    }

    let ctx = self.context_stack.get!(self.context_stack.size - 1)
    if self.current().is(Delim, "{", self.source) && ctx.struct_literal_allowed {
        let loc = ident.loc
        let body = self.parse_code_expr_map()?
        loc.end_pos = body.loc.end_pos

        return Ok(CodeExpr::StructLiteral(self.ast_arena.new!(StructLiteralExpr {
            struct_name: ident,
            body: body,
            loc: loc,
        })))
    }

    if self.current().is(Delim, "(", self.source) {
        let loc = ident.loc

        self.push_ctx(ParsingContext {
            struct_literal_allowed: true,
        })

        let args = self.parse_fn_args()?

        self.pop_ctx()

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::FnCall(self.ast_arena.new!(FnCallExpr {
            fn_name: ident,
            args: args,
            loc: loc,
        })))
    }

    if self.eat(Operator, "!") != null {
        let excl_end_pos = self.prev().loc.end_pos

        let loc = ident.loc

        let type_args = self.parse_macro_type_args()?
        let args = self.parse_fn_args()?

        loc.end_pos = self.prev().loc.end_pos

        let result = self.ast_arena.new!(MacroFnCallExpr {
            fn_name: ident,
            type_args: type_args,
            args: args,
            loc: loc,
        })

        self.extend_ident(&result.fn_name, excl_end_pos)

        return Ok(CodeExpr::MacroFnCall(result))
    }

    return Ok(CodeExpr::Ident(self.ast_arena.new!(ident)))
}

fn Parser::parse_code_expr_postfix(
    &self,
    primary: CodeExpr,
    op: InfixOp,
    op_loc: Loc,
): Result(CodeExpr, &Error) {
    if op.tag == InfixOpTag::Equal \
        || op.tag == InfixOpTag::NotEqual \
        || op.tag == InfixOpTag::Less \
        || op.tag == InfixOpTag::Greater \
        || op.tag == InfixOpTag::LessEqual \
        || op.tag == InfixOpTag::GreaterEqual \
        || op.tag == InfixOpTag::Add \
        || op.tag == InfixOpTag::Sub \
        || op.tag == InfixOpTag::Mul \
        || op.tag == InfixOpTag::Div \
        || op.tag == InfixOpTag::Mod \
        || op.tag == InfixOpTag::And \
        || op.tag == InfixOpTag::BitAnd \
        || op.tag == InfixOpTag::Or \
        || op.tag == InfixOpTag::BitOr \
        || op.tag == InfixOpTag::ShiftLeft \
        || op.tag == InfixOpTag::ShiftRight \
        || op.tag == InfixOpTag::AddAssign \
        || op.tag == InfixOpTag::SubAssign \
        || op.tag == InfixOpTag::MulAssign \
        || op.tag == InfixOpTag::DivAssign \
        || op.tag == InfixOpTag::ModAssign \
        || op.tag == InfixOpTag::BitAndAssign \
        || op.tag == InfixOpTag::BitOrAssign \
        || op.tag == InfixOpTag::ShiftLeftAssign \
        || op.tag == InfixOpTag::ShiftRightAssign
    {
        let lhs = primary
        let rhs = self.parse_code_expr(op.bp_next)?

        let loc = lhs.loc()
        loc.end_pos = rhs.loc().end_pos

        return Ok(CodeExpr::InfixOp(self.ast_arena.new!(InfixOpExpr {
            op_tag: op.tag,
            op_loc: op_loc,
            lhs: lhs,
            rhs: rhs,
            loc: loc,
        })))
    }

    if op.tag == InfixOpTag::Cast {
        let loc = primary.loc()

        let casted_to = self.parse_type_expr()?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::Cast(self.ast_arena.new!(CastExpr {
            expr: primary,
            casted_to: casted_to,
            loc: loc,
        })))
    }

    if op.tag == InfixOpTag::FieldAccess {
        let loc = primary.loc()

        let field_name = self.parse_ident()?

        if self.current().is(Delim, "(", self.source) {
            let args = self.parse_fn_args()?

            loc.end_pos = self.prev().loc.end_pos

            return Ok(CodeExpr::MethodCall(self.ast_arena.new!(MethodCallExpr {
                lhs: primary,
                field_name: field_name,
                args: args,
                loc: loc,
            })))
        }

        if self.eat(Operator, "!") != null {
            let excl_end_pos = self.prev().loc.end_pos

            let type_args = self.parse_macro_type_args()?
            let args = self.parse_fn_args()?

            loc.end_pos = self.prev().loc.end_pos

            let result = self.ast_arena.new!(MacroMethodCallExpr {
                lhs: primary,
                field_name: field_name,
                type_args: type_args,
                args: args,
                loc: loc,
            })

            self.extend_ident(&result.field_name, excl_end_pos)

            return Ok(CodeExpr::MacroMethodCall(result))
        }

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::FieldAccess(self.ast_arena.new!(FieldAccessExpr {
            lhs: primary,
            field_name: field_name,
            loc: loc,
        })))
    }

    if op.tag == InfixOpTag::Assign {
        let loc = primary.loc()

        let value = self.parse_code_expr(op.bp_next)?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::Assign(self.ast_arena.new!(AssignExpr {
            op_loc: op_loc,
            lhs: primary,
            rhs: value,
            loc: loc,
        })))
    }

    if op.tag == InfixOpTag::Catch {
        let loc = primary.loc()

        let error_bind = self.parse_ident()?
        let catch_body = self.parse_code_block()?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::Catch(self.ast_arena.new!(CatchExpr {
            lhs: primary,
            error_bind: error_bind,
            catch_body: catch_body,
            catch_loc: op_loc,
            loc: loc,
        })))
    }

    if op.tag == InfixOpTag::ErrorPropagation {
        let loc = primary.loc()
        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::PropagateError(self.ast_arena.new!(PropagateErrorExpr {
            expr: primary,
            loc: loc,
        })))
    }

    if op.tag == InfixOpTag::ExprPipe {
        let loc = primary.loc()

        let rhs = self.parse_code_expr(op.bp_next)?

        loc.end_pos = self.prev().loc.end_pos

        return Ok(CodeExpr::ExprPipe(self.ast_arena.new!(ExprPipeExpr {
            lhs: primary,
            rhs: rhs,
            op_loc: op_loc,
            loc: loc,
        })))
    }

    @unreachable()
}

fn Parser::parse_fn_args(&self): Result(CodeExprList, &Error) {
    let has_trailing_comma = false
    let items = Vec::new!<CodeExpr>()

    let _ = self.expect(Delim, "(")?
    while self.eat(Delim, ")") == null {
        items.push!(self.parse_code_expr(0)?)

        if !self.current().is(Delim, ")", self.source) {
            let _ = self.expect(Delim, ",")?
            has_trailing_comma = true
        } else {
            has_trailing_comma = false
        }
    }

    return Ok(CodeExprList {
        items: items,
        has_trailing_comma: has_trailing_comma,
    })
}

fn Parser::parse_macro_type_args(&self): Result(&Vec(TypeExpr), &Error) {
    let type_args = Vec::new!<TypeExpr>()

    if self.eat(Operator, "<") == null {
        return Ok(type_args)
    }

    while self.eat(Operator, ">") == null {
        type_args.push!(self.parse_type_expr()?)

        if !self.current().is(Operator, ">", self.source) {
            let _ = self.expect(Delim, ",")?
        }
    }

    return Ok(type_args)
}

fn Parser::parse_match_header(&self): Result(MatchHeader, &Error) {
    let variant_name = self.parse_ident()?
    let _ = self.expect(Delim, "(")?
    let variant_bind = self.parse_ident()?
    let _ = self.expect(Delim, ")")?
    let _ = self.expect(Operator, "=")?
    let expr_to_match = self.parse_code_expr(0)?

    return Ok(MatchHeader {
        variant_name: variant_name,
        variant_bind: variant_bind,
        expr_to_match: expr_to_match,
    })
}

fn Parser::has_backslashes_between(
    &self,
    start_hint: &u32,
    offset_start: u32,
    offset_end: u32,
): bool {
    let i = *start_hint

    while i < self.lexer.backslashes.size {
        let backslash = self.lexer.backslashes.at!(i)
        if backslash.pos.offset < offset_start {
            i += 1
            continue
        }

        *start_hint = i
        return backslash.end_pos.offset <= offset_end
    }

    *start_hint = i
    return false
}

fn Parser::extend_ident(&self, ident: &IdentExpr, new_end_pos: Pos) {
    ident.loc.end_pos = new_end_pos
    ident.repr = ident.loc.read_span(self.source)
}

// utils

fn Parser::push_ctx(&self, ctx: ParsingContext) {
    self.context_stack.push!(ctx)
}

fn Parser::pop_ctx(&self) {
    self.context_stack.pop()
}

fn Parser::expect(&self, type_: TokenType, value: str): Result(&Token, &Error) {
    let token = self.current()
    if !token.is(type_, value, self.lexer.source) {
        let message = String::from_str_in(
            self.error_arena,
            "Unexpected token '",
        )
        message.push_str(token.get_value(self.lexer.source))
        message.push_str("', wanted '")
        message.push_str(value)
        message.push_str("'")

        return Err(self.error_arena.new!(Error {
            message: message,
            loc: token.loc,
        }))
    }

    return Ok(self.next())
}

fn Parser::expect_any(&self, type_: TokenType): Result(&Token, &Error) {
    let token = self.current()
    if !token.is_any(type_) {
        let message = String::from_str_in(
            self.error_arena,
            "Unexpected token '",
        )
        message.push_str(token.get_value(self.lexer.source))
        message.push_str("', wanted '")
        message.push_str(type_.to_str())
        message.push_str("'")

        return Err(self.error_arena.new!(Error {
            message: message,
            loc: token.loc,
        }))
    }

    return Ok(self.next())
}

fn Parser::eat(&self, type_: TokenType, value: str): &Token {
    if !self.current().is(type_, value, self.lexer.source) {
        return null
    }

    return self.next()
}

fn Parser::eat_any(&self, type_: TokenType): &Token {
    if !self.current().is_any(type_) {
        return null
    }

    return self.next()
}

// returns current or terminal token
fn Parser::current(&self): &Token {
    let index = self.tokens_processed
    if index >= self.lexer.tokens.size - 1 {
        index = self.lexer.tokens.size - 1
    }

    return self.lexer.tokens.at!(index)
}

fn Parser::prev(&self): &Token {
    return self.lexer.tokens.at!(self.tokens_processed - 1)
}

fn Parser::next(&self): &Token {
    let token = self.current()
    self.tokens_processed += 1
    return token
}
