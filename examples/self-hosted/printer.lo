include "./core.lo"
include "./ast.lo"
include "./parser.lo"
include "./lexer.lo"

type Printer = struct {
    parser: &Parser,

    indent: u32,
    comments_printed: u32,
    last_printed_item_line: u32,
    backslashes_printed: u32,
    backslash_stack: &Vec(bool),
    last_stmt_had_backslash: bool,
    double_backslashes_printed: u32,
}

fn Printer::new(parser: &Parser): &Printer {
    return heap::new!(Printer {
        parser: parser,

        indent: 0,
        comments_printed: 0,
        last_printed_item_line: 1,
        backslashes_printed: 0,
        backslash_stack: Vec::new!<bool>(),
        last_stmt_had_backslash: false,
        double_backslashes_printed: 0,
    })
}

fn Printer::free(&self) {
    self.backslash_stack.free()
    heap::free(self)
}

fn Printer::print_file(&self) {
    stdout_enable_buffering()

    for i in 0..self.parser.ast.size {
        let expr = self.parser.ast.get!(i)
        self.print_top_level_expr(expr)
    }

    // print the rest of the comments
    self.print_comments_before(Pos {
        offset: u32::MAX,
        line: self.last_printed_item_line,
        col: u32::MAX,
    })

    stdout_disable_buffering()
}

fn Printer::print_top_level_expr(&self, expr: TopLevelExpr) {
    defer if true {
        stdout_write("\n")
        self.last_printed_item_line = expr.loc().end_pos.line
    }

    self.print_comments_before(expr.loc().pos)

    if match TopLevelExpr::FnDef(fn_def) = expr {
        if fn_def.exported {
            stdout_write("export ")
        }
        if fn_def.is_inline {
            stdout_write("inline ")
        }
        self.print_fn_decl(fn_def.decl)

        self.print_code_block(*fn_def.body)
        return
    }

    if match TopLevelExpr::MemoryDef(memory_def) = expr {
        self.print_memory_def(*memory_def)
        return
    }

    if match TopLevelExpr::Include(include_expr) = expr {
        stdout_write("include ")
        stdout_write(include_expr.file_path.get_repr(self.parser.lexer.source))
        if include_expr.alias != null {
            stdout_write(" as ")
            stdout_write(include_expr.alias.repr)
        }
        if include_expr.with_extern {
            stdout_write(" with extern")
        }
        return
    }

    if match TopLevelExpr::Import(import_expr) = expr {
        stdout_write("import from ")
        stdout_write(import_expr.module_name.get_repr(self.parser.lexer.source))
        stdout_writeln(" {")
        self.indent += 1

        for i in 0..import_expr.items.size {
            let item = import_expr.items.get!(i)
            self.print_comments_before(item.loc().pos)
            self.print_indent()
            if match ImportItem::FnDecl(decl) = item {
                self.print_fn_decl(*decl)
            } else if match ImportItem::Memory(memory_def) = item {
                self.print_memory_def(*memory_def)
            } else {
                @unreachable()
            }
            stdout_write("\n")
        }

        // print the rest of the comments
        self.print_comments_before(import_expr.loc.end_pos)

        self.indent -= 1
        self.print_indent()
        stdout_write("}")
        return
    }

    if match TopLevelExpr::Let(let_expr) = expr {
        if let_expr.is_inline {
            stdout_write("inline ")
        }
        stdout_write("let ")
        stdout_write(let_expr.name.repr)
        stdout_write(" = ")
        self.print_code_expr(let_expr.value)
        return
    }

    if match TopLevelExpr::StructDef(struct_def) = expr {
        stdout_write("type ")
        stdout_write(struct_def.struct_name.repr)
        stdout_write(" = struct")

        if struct_def.fields.size == 0 {
            stdout_write(" {}")
            return
        }

        stdout_writeln(" {")
        self.indent += 1
        for i in 0..struct_def.fields.size {
            let field = struct_def.fields.get!(i)
            self.print_comments_before(field.loc.pos)
            self.print_indent()
            stdout_write(field.field_name.repr)
            stdout_write(": ")
            self.print_type_expr(field.field_type)
            stdout_writeln(",")
        }

        // print the rest of the comments
        self.print_comments_before(struct_def.loc.end_pos)

        self.indent -= 1
        self.print_indent()

        stdout_write("}")

        return
    }

    if match TopLevelExpr::EnumDef(enum_def) = expr {
        stdout_write("type ")
        stdout_write(enum_def.enum_name.repr)
        stdout_write(" = enum")

        if enum_def.variant_type != null {
            stdout_write(" (")
            self.print_type_expr(*enum_def.variant_type)
            stdout_write(")")
        }

        if enum_def.variants.size == 0 {
            stdout_write(" {}")
            return
        }

        stdout_writeln(" {")
        self.indent += 1
        for i in 0..enum_def.variants.size {
            let variant = enum_def.variants.get!(i)
            self.print_comments_before(variant.loc.pos)
            self.print_indent()
            stdout_write(variant.variant_name.repr)
            if variant.variant_type != null {
                stdout_write("(")
                self.print_type_expr(*variant.variant_type)
                stdout_write(")")
            }
            stdout_writeln(",")
        }

        // print the rest of the comments
        self.print_comments_before(enum_def.loc.end_pos)

        self.indent -= 1
        self.print_indent()

        stdout_write("}")
        return
    }

    if match TopLevelExpr::TypeDef(type_def) = expr {
        stdout_write("type ")
        stdout_write(type_def.type_name.repr)
        stdout_write(" = ")
        self.print_type_expr(type_def.type_value)
        return
    }

    if match TopLevelExpr::IntrinsicCall(instrinsic) = expr {
        stdout_write("@")
        stdout_write(instrinsic.fn_name.repr)
        self.print_type_args(instrinsic.type_args)
        self.print_args(instrinsic.args, instrinsic.loc)
        return
    }

    @unreachable()
}

fn Printer::print_fn_decl(&self, fn_decl: FnDeclExpr) {
    stdout_write("fn ")
    stdout_write(fn_decl.fn_name.repr)

    if fn_decl.type_params.size != 0 {
        stdout_write("<")
        for i in 0..fn_decl.type_params.size {
            let type_param = fn_decl.type_params.get!(i)
            stdout_write(type_param)
            if i != fn_decl.type_params.size - 1 {
                stdout_write(",")
            }
        }
        stdout_write(">")
    }

    self.print_fn_params(fn_decl.params, fn_decl.params_trailing_comma)

    if fn_decl.return_type != null {
        stdout_write(": ")
        self.print_type_expr(*fn_decl.return_type)
    }

    self.last_printed_item_line = fn_decl.loc.end_pos.line
}

fn Printer::print_fn_params(&self, params: &Vec(FnParam), is_multiline: bool) {
    stdout_write("(")

    if is_multiline {
        self.indent += 1
        stdout_write("\n")
    }

    for i in 0..params.size {
        let param = params.get!(i)

        if i != 0 {
            stdout_write(",")
        }

        let continues = self.print_double_backslashes_before(param.loc.pos.offset)

        if is_multiline && !continues {
            if i != 0 {
                stdout_write("\n")
            }

            self.print_comments_before(param.loc.pos)
            self.print_indent()
        } else if i != 0 {
            stdout_write(" ")
        }

        if match FnParamType::Self(_) = param.param_type {
            stdout_write(param.param_name.repr)
        } else if match FnParamType::SelfRef(_) = param.param_type {
            stdout_write("&")
            stdout_write(param.param_name.repr)
        } else if match FnParamType::Type(type_expr) = param.param_type {
            stdout_write(param.param_name.repr)
            stdout_write(": ")
            self.print_type_expr(type_expr.expr)
        } else if match FnParamType::Infer(infer) = param.param_type {
            stdout_write(param.param_name.repr)
            stdout_write(": infer ")
            stdout_write(infer.name)
        } else {
            @unreachable()
        }

        self.last_printed_item_line = param.loc.pos.line
    }

    if is_multiline {
        stdout_writeln(",")
        self.indent -= 1
        self.print_indent()
    }

    stdout_write(")")
}

fn Printer::print_memory_def(&self, mem: MemoryDefExpr) {
    if mem.exported {
        stdout_write("export ")
    }
    stdout_write("memory ")
    self.print_code_expr_map(mem.params)
}

fn Printer::print_type_expr(&self, expr: TypeExpr) {
    if match TypeExpr::Named(named) = expr {
        stdout_write(named.name.repr)
        return
    }

    if match TypeExpr::Pointer(pointer) = expr {
        stdout_write("&")
        self.print_type_expr(pointer.pointee)
        return
    }

    if match TypeExpr::SequencePointer(pointer) = expr {
        stdout_write("*&")
        self.print_type_expr(pointer.pointee)
        return
    }

    if match TypeExpr::Container(container_expr) = expr {
        self.print_type_expr(container_expr.container)
        stdout_write("(")
        for i in 0..container_expr.items.size {
            let item = container_expr.items.get!(i)
            if i != 0 {
                stdout_write(", ")
            }
            self.print_type_expr(item)
        }
        stdout_write(")")
        return
    }

    @unreachable()
}

fn Printer::print_code_block(&self, code_block: CodeBlock) {
    if self.last_stmt_had_backslash {
        self.last_stmt_had_backslash = false
        stdout_write("\n")
        self.print_indent()
    } else {
        stdout_write(" ")
    }

    if code_block.loc.pos.line == code_block.loc.end_pos.line {
        return stdout_write("{}")
    }

    stdout_write("{")
    self.last_printed_item_line = code_block.loc.pos.line

    self.indent += 1

    for i in 0..code_block.exprs.size {
        let expr = code_block.exprs.get!(i)

        let continues = self.print_double_backslashes_before(expr.loc().pos.offset)
        if continues {
            stdout_write(" ")
        } else {
            stdout_write("\n")
            self.print_comments_before(expr.loc().pos)
            self.print_indent()
        }

        self.print_code_expr(expr)
        self.last_stmt_had_backslash = false
    }
    stdout_write("\n")

    self.print_comments_before(code_block.loc.end_pos)

    self.indent -= 1

    self.print_indent()
    stdout_write("}")
}

fn Printer::print_code_expr(&self, expr: CodeExpr) {
    self.backslash_stack.push!(false)
    defer if true {
        self.last_printed_item_line = expr.loc().end_pos.line
        self.backslash_stack.pop()
    }

    if match CodeExpr::BoolLiteral(bool) = expr {
        if bool.value {
            stdout_write("true")
        } else {
            stdout_write("false")
        }
        return
    }

    if match CodeExpr::CharLiteral(char) = expr {
        stdout_write(char.repr)
        return
    }

    if match CodeExpr::NullLiteral(e) = expr {
        stdout_write("null")
        return
    }

    if match CodeExpr::IntLiteral(int_literal) = expr {
        stdout_write(int_literal.repr)
        if int_literal.tag != null {
            stdout_write(*int_literal.tag)
        }
        return
    }

    if match CodeExpr::StringLiteral(string) = expr {
        stdout_write(string.repr)
        return
    }

    if match CodeExpr::ArrayLiteral(array) = expr {
        stdout_write("[")
        self.print_type_expr(array.item_type)
        stdout_write("]")

        stdout_write("[")
        self.print_expr_list(array.items, array.has_trailing_comma, array.loc)
        stdout_write("]")
        return
    }

    if match CodeExpr::ResultLiteral(result) = expr {
        if result.is_ok {
            stdout_write("Ok")
        } else {
            stdout_write("Err")
        }
        if result.result_type != null {
            stdout_write(":<")
            self.print_type_expr(result.result_type.ok)
            stdout_write(", ")
            self.print_type_expr(result.result_type.err)
            stdout_write(">")
        }
        stdout_write("(")
        if result.value != null {
            self.print_code_expr(*result.value)
        }
        stdout_write(")")
        return
    }

    if match CodeExpr::StructLiteral(struct_literal) = expr {
        stdout_write(struct_literal.struct_name.repr)
        stdout_write(" ")
        self.print_code_expr_map(struct_literal.body)
        return
    }

    if match CodeExpr::Ident(ident) = expr {
        stdout_write(ident.repr)
        return
    }

    if match CodeExpr::Let(let_expr) = expr {
        if let_expr.is_inline {
            stdout_write("inline ")
        }
        stdout_write("let ")
        stdout_write(let_expr.name.repr)
        stdout_write(" = ")
        self.print_code_expr(let_expr.value)
        return
    }

    if match CodeExpr::Return(return_) = expr {
        stdout_write("return")
        if return_.expr != null {
            stdout_write(" ")
            self.print_code_expr(*return_.expr)
        }
        return
    }

    if match CodeExpr::InfixOp(infix_op) = expr {
        self.print_code_expr(infix_op.lhs)
        if !self.print_backslashes_before(infix_op.op_loc.pos.offset) {
            stdout_write(" ")
        }
        stdout_write(infix_op.op_loc.read_span(self.parser.lexer.source))
        stdout_write(" ")
        self.print_code_expr(infix_op.rhs)
        return
    }

    if match CodeExpr::ExprPipe(pipe) = expr {
        self.print_code_expr(pipe.lhs)
        if !self.print_backslashes_before(pipe.op_loc.pos.offset) {
            stdout_write(" ")
        }
        stdout_write(pipe.op_loc.read_span(self.parser.lexer.source))
        stdout_write(" ")
        self.print_code_expr(pipe.rhs)
        return
    }

    if match CodeExpr::PrefixOp(op) = expr {
        stdout_write(op.op_loc.read_span(self.parser.lexer.source))
        self.print_code_expr(op.expr)
        return
    }

    if match CodeExpr::If(return_) = expr {
        stdout_write("if")
        stdout_write(" ")

        if match IfCond::Expr(expr) = return_.cond {
            self.print_code_expr(*expr)
        } else if match IfCond::Match(match_header) = return_.cond {
            self.print_match_header(*match_header)
        } else {
            @unreachable()
        }

        self.print_code_block(return_.then_block)

        if match ElseBlock::None(_) = return_.else_block {
            // nothing
        } else if match ElseBlock::Else(else_block) = return_.else_block {
            stdout_write(" ")
            stdout_write("else")
            self.print_code_block(*else_block)
        } else if match ElseBlock::ElseIf(if_expr) = return_.else_block {
            stdout_write(" ")
            stdout_write("else")
            stdout_write(" ")
            self.print_code_expr(*if_expr)
        }

        return
    }

    if match CodeExpr::Match(match_expr) = expr {
        self.print_match_header(match_expr.header)
        stdout_write(" else")
        self.print_code_block(match_expr.else_branch)
        return
    }

    if match CodeExpr::While(while_expr) = expr {
        if while_expr.cond != null {
            stdout_write("while ")
            self.print_code_expr(*while_expr.cond)
        } else {
            stdout_write("loop")
        }
        self.print_code_block(while_expr.body)
        return
    }

    if match CodeExpr::For(for_expr) = expr {
        stdout_write("for ")
        stdout_write(for_expr.counter.repr)
        stdout_write(" in ")
        self.print_code_expr(for_expr.start)
        stdout_write("..")
        self.print_code_expr(for_expr.end)
        self.print_code_block(for_expr.body)
        return
    }

    if match CodeExpr::Break(e) = expr {
        stdout_write("break")
        return
    }

    if match CodeExpr::Continue(e) = expr {
        stdout_write("continue")
        return
    }

    if match CodeExpr::DoWith(do_with) = expr {
        stdout_write("do ")
        self.print_code_expr(do_with.body)
        stdout_write(" with ")
        self.print_args(do_with.args, do_with.loc)
        return
    }

    if match CodeExpr::Defer(defer_expr) = expr {
        stdout_write("defer ")
        self.print_code_expr(defer_expr.expr)
        return
    }

    if match CodeExpr::Cast(cast) = expr {
        self.print_code_expr(cast.expr)
        stdout_write(" as ")
        self.print_type_expr(cast.casted_to)
        return
    }

    if match CodeExpr::Assign(assign) = expr {
        self.print_code_expr(assign.lhs)
        stdout_write(" = ")
        self.print_code_expr(assign.rhs)
        return
    }

    if match CodeExpr::FieldAccess(access) = expr {
        self.print_code_expr(access.lhs)
        let _ = self.print_backslashes_before(access.field_name.loc.pos.offset)
        stdout_write(".")
        stdout_write(access.field_name.repr)
        return
    }

    if match CodeExpr::Catch(catch_expr) = expr {
        self.print_code_expr(catch_expr.lhs)
        stdout_write(" catch ")
        stdout_write(catch_expr.error_bind.repr)
        self.print_code_block(catch_expr.catch_body)
        return
    }

    if match CodeExpr::Paren(paren) = expr {
        stdout_write("(")
        self.last_printed_item_line = paren.loc.pos.line

        if paren.has_trailing_comma {
            stdout_write("\n")
            self.indent += 1
            self.print_comments_before(paren.expr.loc().pos)
            self.print_indent()
        }

        self.print_code_expr(paren.expr)

        if paren.has_trailing_comma {
            self.indent -= 1
            stdout_writeln(",")
            self.print_indent()
        }
        stdout_write(")")
        return
    }

    if match CodeExpr::FnCall(call) = expr {
        stdout_write(call.fn_name.repr)
        self.print_args(call.args, call.loc)
        return
    }

    if match CodeExpr::MethodCall(call) = expr {
        self.print_code_expr(call.lhs)
        let _ = self.print_backslashes_before(call.field_name.loc.pos.offset)
        stdout_write(".")
        stdout_write(call.field_name.repr)
        self.print_args(call.args, call.field_name.loc)
        return
    }

    if match CodeExpr::InlineFnCall(inline_fn_call) = expr {
        stdout_write(inline_fn_call.fn_name.repr)
        self.print_type_args(inline_fn_call.type_args)
        self.print_args(inline_fn_call.args, inline_fn_call.loc)
        return
    }

    if match CodeExpr::IntrinsicCall(instrinsic) = expr {
        stdout_write("@")
        stdout_write(instrinsic.fn_name.repr)
        self.print_type_args(instrinsic.type_args)
        self.print_args(instrinsic.args, instrinsic.loc)
        return
    }

    if match CodeExpr::InlineFnMethodCall(call) = expr {
        self.print_code_expr(call.lhs)
        let _ = self.print_backslashes_before(call.field_name.loc.pos.offset)
        stdout_write(".")
        stdout_write(call.field_name.repr)
        self.print_type_args(call.type_args)
        self.print_args(call.args, call.field_name.loc)
        return
    }

    if match CodeExpr::Sizeof(sizeof_expr) = expr {
        stdout_write("sizeof ")
        self.print_type_expr(sizeof_expr.type_expr)
        return
    }

    if match CodeExpr::PropagateError(prop_err) = expr {
        self.print_code_expr(prop_err.expr)
        stdout_write("?")
        return
    }

    @unreachable()
}

fn Printer::print_code_expr_map(&self, map: CodeExprMap) {
    stdout_write("{")
    self.last_printed_item_line = map.loc.pos.line

    if map.has_trailing_comma {
        stdout_write("\n")

        self.indent += 1

        for i in 0..map.fields.size {
            let field = map.fields.get!(i)
            self.print_comments_before(field.loc.pos)
            self.print_indent()
            stdout_write(field.key)
            stdout_write(": ")
            self.print_code_expr(field.value)
            stdout_writeln(",")
        }

        self.print_comments_before(map.loc.end_pos)

        self.indent -= 1
        self.print_indent()
        stdout_write("}")

        return
    }

    if map.fields.size > 0 {
        stdout_write(" ")
    }

    for i in 0..map.fields.size {
        if i != 0 {
            stdout_write(", ")
        }

        let field = map.fields.get!(i)
        stdout_write(field.key)
        stdout_write(": ")
        self.print_code_expr(field.value)
    }

    if map.fields.size > 0 {
        stdout_write(" ")
    }

    stdout_write("}")
}

fn Printer::print_args(&self, args: CodeExprList, open_paren_loc: Loc) {
    stdout_write("(")
    self.print_expr_list(args.items, args.has_trailing_comma, open_paren_loc)
    stdout_write(")")
}

fn Printer::print_expr_list(
    &self,
    exprs: &Vec(CodeExpr),
    is_multiline: bool,
    start_loc: Loc,
) {
    if is_multiline {
        self.indent += 1
        stdout_write("\n")
        self.last_printed_item_line = start_loc.pos.line
    }

    let prev_backslashes_printed = self.backslashes_printed

    for i in 0..exprs.size {
        let arg = exprs.get!(i)

        if i != 0 {
            stdout_write(",")
        }

        let continues = self.print_double_backslashes_before(arg.loc().pos.offset)

        if is_multiline && !continues {
            if i != 0 {
                stdout_write("\n")
            }

            self.print_comments_before(arg.loc().pos)
            self.print_indent()
        } else if i != 0 {
            stdout_write(" ")
        }

        self.print_code_expr(arg)
    }
    if !is_multiline && self.backslashes_printed != prev_backslashes_printed {
        stdout_write("\n")
        self.print_indent()
    }

    if is_multiline {
        stdout_writeln(",")
        self.indent -= 1
        self.print_indent()
    }
}

fn Printer::print_type_args(&self, type_args: &Vec(TypeExpr)) {
    if type_args.size == 0 {
        return
    }

    stdout_write("<")
    for i in 0..type_args.size {
        let type_arg = type_args.get!(i)

        if i != 0 {
            stdout_write(", ")
        }

        self.print_type_expr(type_arg)
    }
    stdout_write(">")
}

fn Printer::print_match_header(&self, header: MatchHeader) {
    stdout_write("match ")
    stdout_write(header.variant_name.repr)
    stdout_write("(")
    stdout_write(header.variant_bind.repr)
    stdout_write(") = ")
    self.print_code_expr(header.expr_to_match)
}

fn Printer::print_comments_before(&self, pos: Pos) {
    while self.comments_printed < self.parser.lexer.comments.size {
        let comment = self.parser.lexer.comments.get!(self.comments_printed)
        if comment.end_pos.offset > pos.offset {
            break
        }

        self.print_blank_line_before(comment.pos.line)
        self.last_printed_item_line = comment.end_pos.line

        self.print_indent()
        stdout_writeln(comment.read_span(self.parser.lexer.source))
        self.comments_printed += 1
    }

    self.print_blank_line_before(pos.line)
    self.last_printed_item_line = pos.line
}

fn Printer::print_blank_line_before(&self, line: u32) {
    let lines_since_last_item = line - self.last_printed_item_line
    if lines_since_last_item > 1 {
        stdout_write("\n")
    }
}

fn Printer::print_backslashes_before(&self, offset: u32): bool {
    let printed = false

    while self.backslashes_printed < self.parser.lexer.backslashes.size {
        let backslash = self.parser.lexer.backslashes.get!(self.backslashes_printed)
        if backslash.end_pos.offset > offset {
            break
        }

        self.backslashes_printed += 1

        if !printed {
            printed = true

            *self.backslash_stack.at!(self.backslash_stack.size - 1) = true
            self.last_stmt_had_backslash = true

            stdout_writeln(" \\")
            self.print_indent()
        }
    }

    return printed
}

fn Printer::print_double_backslashes_before(&self, offset: u32): bool {
    let printed = false

    while self.double_backslashes_printed < self.parser.lexer.double_backslashes.size {
        let dbs = self.parser.lexer.double_backslashes.get!(self.double_backslashes_printed)
        if dbs.end_pos.offset > offset {
            break
        }

        self.double_backslashes_printed += 1

        if !printed {
            printed = true

            stdout_write(" \\\\")
        }
    }

    return printed
}

fn Printer::print_indent(&self) {
    for _ in 0..self.indent {
        stdout_write("    ")
    }

    for i in 0..self.backslash_stack.size {
        if self.backslash_stack.get!(i) {
            stdout_write("    ")
        }
    }
}
