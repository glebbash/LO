include "./core.lo"
include "./ast.lo"
include "./parser.lo"
include "./lexer.lo"

struct Printer {
    parser: &Parser,

    indent: u32,
    comments_printed: u32,
    last_printed_item_line: u32,
    backslashes_printed: u32,
    backslash_stack: &Vec(bool),
    last_stmt_had_backslash: bool,
    double_backslashes_printed: u32,
}

fn Printer::new(parser: &Parser): &Printer {
    return heap::new!(Printer {
        parser: parser,

        indent: 0,
        comments_printed: 0,
        last_printed_item_line: 1,
        backslashes_printed: 0,
        backslash_stack: Vec::new!<bool>(),
        last_stmt_had_backslash: false,
        double_backslashes_printed: 0,
    })
}

fn Printer::free(&self) {
    self.backslash_stack.free()
    heap::free(self)
}

fn Printer::print_file(&self) {
    stdout_enable_buffering()

    for i in 0..self.parser.ast.size {
        let expr = self.parser.ast.get!(i)
        self.print_top_level_expr(expr)
    }

    // print the rest of the comments
    self.print_comments_before(Pos {
        offset: u32::MAX,
        line: self.last_printed_item_line,
        col: u32::MAX,
    })

    stdout_disable_buffering()
}

fn Printer::print_top_level_expr(&self, expr: TopLevelExpr) {
    self.print_comments_before(expr.loc().pos)

    if match TopLevelExpr::FnDef(fn_def) = expr {
        if fn_def.exported {
            stdout_write("export ")
        }
        self.print_fn_decl(fn_def.decl)

        self.print_code_block(*fn_def.body)
        stdout_write("\n")
        return
    }

    if match TopLevelExpr::Include(include_expr) = expr {
        stdout_write("include ")
        stdout_write(include_expr.file_path.get_repr(self.parser.lexer.source))
        if include_expr.alias != null {
            stdout_write(" as ")
            stdout_write(include_expr.alias.repr)
        }
        if include_expr.with_extern {
            stdout_write(" with extern")
        }
        stdout_write("\n")
        return
    }

    todo!()
}

fn Printer::print_fn_decl(&self, fn_decl: FnDeclExpr) {
    stdout_write("fn ")
    stdout_write(fn_decl.fn_name.repr)
    self.print_fn_params(fn_decl.fn_params, fn_decl.fn_params_trailing_comma)

    if fn_decl.return_type != null {
        stdout_write(": ")
        self.print_type_expr(*fn_decl.return_type)
    }
}

fn Printer::print_fn_params(&self, params: &Vec(FnParam), is_multiline: bool) {
    stdout_write("(")

    if is_multiline {
        self.indent += 1
        stdout_write("\n")
    }

    for index in 0..params.size {
        let param = params.get!(index)

        if index != 0 {
            stdout_write(",")
        }

        let continues = self.print_double_backslashes_before(param.loc.pos.offset)

        if is_multiline && !continues {
            if index != 0 {
                stdout_write("\n")
            }

            self.print_comments_before(param.loc.pos)
            self.print_indent()
        } else if index != 0 {
            stdout_write(" ")
        }

        if match FnParamType::Self(_) = param.param_type {
            stdout_write(param.param_name.repr)
        } else if match FnParamType::SelfRef(_) = param.param_type {
            stdout_write("&")
            stdout_write(param.param_name.repr)
        } else if match FnParamType::Type(type_expr) = param.param_type {
            stdout_write(param.param_name.repr)
            stdout_write(": ")
            self.print_type_expr(type_expr.expr)
        } else if match FnParamType::Infer(infer) = param.param_type {
            stdout_write(param.param_name.repr)
            stdout_write(": infer ")
            stdout_write(infer.name)
        } else {
            @unreachable()
        }

        self.last_printed_item_line = param.loc.pos.line
    }

    if is_multiline {
        stdout_writeln(",")
        self.indent -= 1
        self.print_indent()
    }

    stdout_write(")")
}

fn Printer::print_type_expr(&self, expr: TypeExpr) {
    if match TypeExpr::Named(named) = expr {
        stdout_write(named.name.repr)
    } else {
        todo!()
    }
}

fn Printer::print_code_block(&self, code_block: CodeBlock) {
    if self.last_stmt_had_backslash {
        self.last_stmt_had_backslash = false
        stdout_write("\n")
        self.print_indent()
    } else {
        stdout_write(" ")
    }

    if code_block.loc.pos.line == code_block.loc.end_pos.line {
        return stdout_write("{}")
    }

    stdout_write("{")
    self.last_printed_item_line = code_block.loc.pos.line

    self.indent += 1

    for i in 0..code_block.exprs.size {
        let expr = code_block.exprs.get!(i)

        let continues = self.print_double_backslashes_before(expr.loc().pos.offset)
        if continues {
            stdout_write(" ")
        } else {
            stdout_write("\n")
            self.print_comments_before(expr.loc().pos)
            self.print_indent()
        }

        self.print_code_expr(expr)
        self.last_stmt_had_backslash = false
    }
    stdout_write("\n")

    self.print_comments_before(code_block.loc.end_pos)

    self.indent -= 1

    self.print_indent()
    stdout_write("}")
}

fn Printer::print_code_expr(&self, expr: CodeExpr) {
    self.backslash_stack.push!(false)
    defer self.backslash_stack.pop()

    if match CodeExpr::IntLiteral(int_literal) = expr {
        stdout_write(int_literal.repr)
        if int_literal.tag != null {
            stdout_write(*int_literal.tag)
        }
        return
    }

    if match CodeExpr::Ident(ident) = expr {
        stdout_write(ident.repr)
        return
    }

    if match CodeExpr::InfixOp(infix_op) = expr {
        self.print_code_expr(infix_op.lhs)
        if !self.print_backslashes_before(infix_op.op_loc.pos.offset) {
            stdout_write(" ")
        }
        stdout_write(infix_op.op_loc.read_span(self.parser.lexer.source))
        stdout_write(" ")
        self.print_code_expr(infix_op.rhs)
        return
    }

    if match CodeExpr::Let(let_expr) = expr {
        stdout_write("let ")
        stdout_write(let_expr.local_name.repr)
        stdout_write(" = ")
        self.print_code_expr(let_expr.value)
        return
    }

    if match CodeExpr::Return(return_) = expr {
        stdout_write("return")
        if return_.expr != null {
            stdout_write(" ")
            self.print_code_expr(*return_.expr)
        }
        return
    }

    if match CodeExpr::FnCall(fn_call) = expr {
        stdout_write(fn_call.fn_name.repr)
        self.print_args(fn_call.args, fn_call.loc)
        return
    }

    if match CodeExpr::IntrinsicCall(instrinsic) = expr {
        stdout_write("@")
        stdout_write(instrinsic.fn_name.repr)
        self.print_type_args(instrinsic.type_args)
        self.print_args(instrinsic.args, instrinsic.loc)
        return
    }

    if match CodeExpr::If(return_) = expr {
        stdout_write("if")
        stdout_write(" ")

        if match IfCond::Expr(expr) = return_.cond {
            self.print_code_expr(*expr)
        } else if match IfCond::Match(match_header) = return_.cond {
            self.print_match_header(*match_header)
        } else {
            @unreachable()
        }

        self.print_code_block(return_.then_block)

        if match ElseBlock::None(_) = return_.else_block {
            // nothing
        } else if match ElseBlock::Else(else_block) = return_.else_block {
            stdout_write(" ")
            stdout_write("else")
            self.print_code_block(*else_block)
        } else if match ElseBlock::ElseIf(if_expr) = return_.else_block {
            stdout_write(" ")
            stdout_write("else")
            stdout_write(" ")
            self.print_code_expr(*if_expr)
        }

        return
    }

    todo!()
}

fn Printer::print_args(&self, args: CodeExprList, open_paren_loc: Loc) {
    stdout_write("(")
    self.print_expr_list(args.items, args.has_trailing_comma, open_paren_loc)
    stdout_write(")")
}

fn Printer::print_expr_list(
    &self,
    exprs: &Vec(CodeExpr),
    is_multiline: bool,
    start_loc: Loc,
) {
    if is_multiline {
        self.indent += 1
        stdout_write("\n")
        self.last_printed_item_line = start_loc.pos.line
    }

    let prev_backslashes_printed = self.backslashes_printed

    for index in 0..exprs.size {
        let arg = exprs.get!(index)

        if index != 0 {
            stdout_write(",")
        }

        let continues = self.print_double_backslashes_before(arg.loc().pos.offset)

        if is_multiline && !continues {
            if index != 0 {
                stdout_write("\n")
            }

            self.print_comments_before(arg.loc().pos)
            self.print_indent()
        } else if index != 0 {
            stdout_write(" ")
        }

        self.print_code_expr(arg)
    }
    if !is_multiline && self.backslashes_printed != prev_backslashes_printed {
        stdout_write("\n")
        self.print_indent()
    }

    if is_multiline {
        stdout_writeln(",")
        self.indent -= 1
        self.print_indent()
    }
}

fn Printer::print_type_args(&self, type_args: &Vec(TypeExpr)) {
    if type_args.size == 0 {
        return
    }

    stdout_write("<")
    for index in 0..type_args.size {
        let type_arg = type_args.get!(index)

        if index != 0 {
            stdout_write(", ")
        }

        self.print_type_expr(type_arg)
    }
    stdout_write(">")
}

fn Printer::print_match_header(&self, header: MatchHeader) {
    todo!()
}

fn Printer::print_comments_before(&self, pos: Pos) {
    while self.comments_printed < self.parser.lexer.comments.size {
        let comment = self.parser.lexer.comments.get!(self.comments_printed)
        if comment.end_pos.offset > pos.offset {
            break
        }

        self.print_blank_line_before(comment.pos.line)
        self.last_printed_item_line = comment.end_pos.line

        self.print_indent()
        stdout_writeln(comment.read_span(self.parser.lexer.source))
        self.comments_printed += 1
    }

    self.print_blank_line_before(pos.line)
    self.last_printed_item_line = pos.line
}

fn Printer::print_blank_line_before(&self, line: u32) {
    let lines_since_last_item = line - self.last_printed_item_line
    if lines_since_last_item > 1 {
        stdout_write("\n")
    }
}

fn Printer::print_backslashes_before(&self, offset: u32): bool {
    // TODO: implement proper
    return false
}

fn Printer::print_double_backslashes_before(&self, offset: u32): bool {
    // TODO: implement proper
    return false
}

fn Printer::print_indent(&self) {
    for _ in 0..self.indent {
        stdout_write("    ")
    }

    for i in 0..self.backslash_stack.size {
        if self.backslash_stack.get!(i) {
            stdout_write("    ")
        }
    }
}
