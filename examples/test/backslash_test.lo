fn backslash_test() {
    let _ = 1 + 1 \
        + 1

    let _ = (1 \
        + 1) \
        + 1

    let _ = 1 - 1 - (1 - 1) \
        - 1 \
        - 1 \
        - 1

    let _ = 2 + f(
        1,
    ) + f(1)

    let _ = 1 \
        + f(1) \
        + f(1)

    let _ = 1 \
        + f(1 \
            + f(1 \
                + f(1 \
                    + f(1 \
                        + f(1 \
                            + f(1 \
                                + f(1 \
                                    + f(1 \
                                        + f(1)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

    if false {
        let _ = 1 \
            + .s { x: 1 }.x \
            + 1
    }
    let _ = 1 + 1 \
        + (1 \
            + 1 \
            + .s { x: 1 }.x) + 1

    let _ = 1 + f(1 \
        + 1 \
        + 1
    )

    let _ = 1 + f(
        1 \
            + 1 \
            + 1,
    )

    let _ = f2(
        1 \
            + 1,
        1,
    )

    let x = 0 as &InfX
    let _ = x \
        .call(x.x.x.x.call(x)) \
        .call(x \
            .call(
                x.x,
            ) \
            .call(x \
                .x.x.x.x.call(x) \
                .call(
                    x.call(x) \
                        .call(x \
                            .call(x) \
                            .call(x \
                                .x
                            )
                        ),
                )
            )
        ) as u32 \
        + 1
}

struct s {
    x: u32,
}

fn f(x: u32): u32 {
    return .s { x: x }.x
}

fn f2(x: u32, y: u32): u32 {
    return x \
        + y
}

struct InfX {
    x: &InfX,
}

fn InfX::call(&self, other: &InfX): &InfX {
    return self
}
