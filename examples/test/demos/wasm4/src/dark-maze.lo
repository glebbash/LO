include "../../../../lib/std.lo"
include "../../../../lib/wasm4.lo"

// Maze generator: https://keesiemeijer.github.io/maze-generator/#generate
inline let MAZE = @embed_file("../assets/maze.bin")

inline let END1_IMAGE = @embed_file("../assets/end1-image.bin")
inline let END2_IMAGE = @embed_file("../assets/end2-image.bin")

inline let END1_NOTE_DURATION = 15
inline let END1_NOTES = [u8][
    60 as u8, \\ 64 as u8, \\ 67 as u8, \\ 72 as u8,
    67 as u8, \\ 64 as u8, \\ 60 as u8, \\ 55 as u8,
]

inline let END2_NOTE_DURATION = 60
inline let END2_NOTES = [u8][
    36 as u8, \\ 33 as u8, \\ 31 as u8, \\ 29 as u8,
    28 as u8, \\ 26 as u8, \\ 24 as u8, \\ 21 as u8,
]

inline let Color::TRANSPARENT = 0
inline let Color::BLACK = 1
inline let Color::RED = 2
inline let Color::GRAY = 3
inline let Color::WHITE = 4

enum Screen {
    Title,
    Game,
    End1,
    End2,
}

inline let VOLUME = 65

let screen = Screen::Title
let gamepad = 0 as u8
let prev_gamepad = 0 as u8
let pos_x = +42
let pos_y = +46
let light_checked = null as &Vec(u32)
let notes_index = 0
let notes_ticker = 0
let rand_seed = 0

export fn start() {
    stack::SIZE = wasm4::DATA_START
    light_checked = Vec::new!<u32>()

    // Palette (https://lospec.com/palette-list/empty-space-4)
    *array_at!<u32>(wasm4::PALETTE, Color::BLACK - 1) = 0x000100
    *array_at!<u32>(wasm4::PALETTE, Color::RED - 1) = 0x431723
    *array_at!<u32>(wasm4::PALETTE, Color::GRAY - 1) = 0x46464F
    *array_at!<u32>(wasm4::PALETTE, Color::WHITE - 1) = 0x928E80
}

export fn update() {
    prev_gamepad = gamepad
    gamepad = *wasm4::GAMEPAD1

    if screen == Screen::Title {
        title_screen_update()
    } else if screen == Screen::Game {
        game_screen_update()
    } else if screen == Screen::End1 {
        end1_screen_update()
    } else if screen == Screen::End2 {
        end2_screen_update()
    }
}

fn title_screen_update() {
    set_draw_color(Color::WHITE)
    wasm4::text("Dark     \0".data, +46, +60)

    light_block(+1, -1, 1024)
    light_block(+2, -1, 1024)

    set_draw_color(Color::RED)
    wasm4::text("     Maze\0".data, +46, +60)

    set_draw_color(Color::WHITE)
    wasm4::text("Press X to start\0".data, +16, +116)

    set_draw_color(Color::RED)
    wasm4::text("      X\0".data, +16, +116)

    set_draw_color(Color::GRAY)
    wasm4::text("@glebbash 2025\0".data, +24, +146)

    if just_pressed(wasm4::BUTTON_1) {
        screen = Screen::Game
    }
}

fn game_screen_update() {
    light_checked.size = 0
    spread_light(pos_x, pos_y, 1, light_checked)

    let player_size = 4
    let center = (wasm4::SCREEN_SIZE / 2 - player_size / 2) as i32
    set_draw_color(Color::RED)
    wasm4::rect(center, center, player_size, player_size)

    let prev_pos_x = pos_x
    let prev_pos_y = pos_y

    if just_pressed(wasm4::BUTTON_LEFT) {
        pos_x -= +1
    }
    if just_pressed(wasm4::BUTTON_RIGHT) {
        pos_x += +1
    }
    if just_pressed(wasm4::BUTTON_UP) {
        pos_y -= +1
    }
    if just_pressed(wasm4::BUTTON_DOWN) {
        pos_y += +1
    }

    if is_wall(pos_x, pos_y) {
        pos_x = prev_pos_x
        pos_y = prev_pos_y
    }

    if pos_x == +02 && pos_y == +04 {
        screen = Screen::End1
    }

    if pos_x == +84 && pos_y == +82 {
        screen = Screen::End2
    }
}

fn end1_screen_update() {
    set_draw_colors(Color::BLACK, Color::GRAY, Color::RED, Color::WHITE)
    wasm4::blit(END1_IMAGE, +0, +0, 160, 160, wasm4::BLIT_2BPP)
    play_notes(END1_NOTES, @const_slice_len(END1_NOTES), END1_NOTE_DURATION)
}

fn end2_screen_update() {
    set_draw_colors(Color::BLACK, Color::RED, Color::GRAY, Color::WHITE)
    wasm4::blit(END2_IMAGE, +0, +0, 160, 160, wasm4::BLIT_2BPP)
    play_notes(END2_NOTES, @const_slice_len(END2_NOTES), END2_NOTE_DURATION)
}

fn spread_light(x: i32, y: i32, brightness: u32, checked: &Vec(u32)) {
    if is_wall(x, y) || !mark_checked(x, y, checked) {
        return
    }

    light_block(x - pos_x, y - pos_y, brightness)

    if brightness < 16 {
        spread_light(x + +1, y, brightness * 2, checked)
        spread_light(x - +1, y, brightness * 2, checked)
        spread_light(x, y + +1, brightness * 2, checked)
        spread_light(x, y - +1, brightness * 2, checked)
    }
}

fn mark_checked(x: i32, y: i32, checked: &Vec(u32)): bool {
    let pos = x as u32 * 88 + y as u32

    for i in 0..checked.size {
        if checked.get!(i) == pos {
            return false
        }
    }

    checked.push!(pos)
    return true
}

fn is_wall(x: i32, y: i32): bool {
    if x <= +0 || x >= +88 || y <= +0 || y >= +88 {
        return false
    }

    return *array_at!<u8>(MAZE, y as u32 * 88 + x as u32) == 0 as u8
}

fn light_block(block_x: i32, block_y: i32, brightness: u32) {
    let tile_size = 16
    let center = (wasm4::SCREEN_SIZE / 2 - tile_size / 2) as i32
    let sx = center + block_x * tile_size as i32
    let sy = center + block_y * tile_size as i32

    set_draw_color(Color::WHITE)

    for i in 0..tile_size {
        for j in 0..tile_size {
            if rand_u32(brightness) == 0 {
                wasm4::hline(sx + i as i32, sy + j as i32, 1)
            }
        }
    }
}

fn play_notes(notes: *&u8, notes_len: u32, note_duration: u32) {
    if notes_ticker >= note_duration {
        let note = (*array_at!<u8>(notes, notes_index)) as u32
        wasm4::tone(
            note,
            note_duration,
            VOLUME,
            wasm4::TONE_PULSE1 | wasm4::TONE_NOTE_MODE,
        )

        notes_index = (notes_index + 1) % notes_len
        notes_ticker = 0
    }
    notes_ticker += 1
}

fn rand_u32(max: u32): u32 {
    rand_seed = (1664525 * rand_seed + 101390423) % 214748365
    return rand_seed % (max + 1)
}

fn set_draw_color(c1: u32) {
    set_draw_colors(
        c1,
        Color::TRANSPARENT,
        Color::TRANSPARENT,
        Color::TRANSPARENT,
    )
}

fn set_draw_colors(c1: u32, c2: u32, c3: u32, c4: u32) {
    *wasm4::DRAW_COLORS = ((c1 << 00) \
        | (c2 << 04) \
        | (c3 << 08) \
        | (c4 << 12)) as u16
}

fn just_pressed(button: u8): bool {
    if gamepad & button != 0 as u8 {
        if !(prev_gamepad & button) {
            return true
        }
    }
    return false
}
